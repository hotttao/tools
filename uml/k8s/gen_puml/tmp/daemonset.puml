@startuml
namespace daemonset {
    class daemonSetStatusStrategy << (S,Aquamarine) >> {
        + GetResetFields() <font color=blue>map</font>[fieldpath.APIVersion]*fieldpath.Set
        + PrepareForUpdate(ctx context.Context, obj daemonset.Object, old daemonset.Object) 
        + ValidateUpdate(ctx context.Context, obj daemonset.Object, old daemonset.Object) field.ErrorList
        + WarningsOnUpdate(ctx context.Context, obj daemonset.Object, old daemonset.Object) []string

    }
    class daemonSetStrategy << (S,Aquamarine) >> {
        + DefaultGarbageCollectionPolicy(ctx context.Context) daemonset.GarbageCollectionPolicy
        + NamespaceScoped() bool
        + GetResetFields() <font color=blue>map</font>[fieldpath.APIVersion]*fieldpath.Set
        + PrepareForCreate(ctx context.Context, obj daemonset.Object) 
        + PrepareForUpdate(ctx context.Context, obj daemonset.Object, old daemonset.Object) 
        + Validate(ctx context.Context, obj daemonset.Object) field.ErrorList
        + WarningsOnCreate(ctx context.Context, obj daemonset.Object) []string
        + Canonicalize(obj daemonset.Object) 
        + AllowCreateOnUpdate() bool
        + ValidateUpdate(ctx context.Context, obj daemonset.Object, old daemonset.Object) field.ErrorList
        + WarningsOnUpdate(ctx context.Context, obj daemonset.Object, old daemonset.Object) []string
        + AllowUnconditionalUpdate() bool

    }
}
"daemonset.daemonSetStrategy" *-- "daemonset.daemonSetStatusStrategy"
"names.NameGenerator" *-- "daemonset.daemonSetStrategy"
"daemonset.ObjectTyper" *-- "daemonset.daemonSetStrategy"

"daemonset.ResetFieldsStrategy" <|-- "daemonset.daemonSetStatusStrategy"
"daemonset.GarbageCollectionDeleteStrategy" <|-- "daemonset.daemonSetStrategy"
"daemonset.NamespaceScopedStrategy" <|-- "daemonset.daemonSetStrategy"
"daemonset.RESTCreateStrategy" <|-- "daemonset.daemonSetStrategy"
"daemonset.RESTUpdateStrategy" <|-- "daemonset.daemonSetStrategy"
"daemonset.ResetFieldsStrategy" <|-- "daemonset.daemonSetStrategy"
"daemonset.Scoper" <|-- "daemonset.daemonSetStrategy"

namespace daemonset {
    interface CategoriesProvider  {
        + Categories() []string

    }
    interface CollectionDeleter  {
        + DeleteCollection(ctx context.Context, deleteValidation ValidateObjectFunc, options *v1.DeleteOptions, listOptions *internalversion.ListOptions) (daemonset.Object, error)

    }
    interface Connecter  {
        + Connect(ctx context.Context, id string, options daemonset.Object, r Responder) (http.Handler, error)
        + NewConnectOptions() (daemonset.Object, bool, string)
        + ConnectMethods() []string

    }
    interface CreateUpdateResetFieldsStrategy  {
    }
    interface Creater  {
        + New() daemonset.Object
        + Create(ctx context.Context, obj daemonset.Object, createValidation ValidateObjectFunc, options *v1.CreateOptions) (daemonset.Object, error)

    }
    interface CreaterUpdater  {
        + Update(ctx context.Context, name string, objInfo UpdatedObjectInfo, createValidation ValidateObjectFunc, updateValidation ValidateObjectUpdateFunc, forceAllowCreate bool, options *v1.UpdateOptions) (daemonset.Object, bool, error)

    }
    interface GarbageCollectionDeleteStrategy  {
        + DefaultGarbageCollectionPolicy(ctx context.Context) GarbageCollectionPolicy

    }
    interface Getter  {
        + Get(ctx context.Context, name string, options *v1.GetOptions) (daemonset.Object, error)

    }
    interface GetterWithOptions  {
        + Get(ctx context.Context, name string, options daemonset.Object) (daemonset.Object, error)
        + NewGetOptions() (daemonset.Object, bool, string)

    }
    interface GracefulDeleter  {
        + Delete(ctx context.Context, name string, deleteValidation ValidateObjectFunc, options *v1.DeleteOptions) (daemonset.Object, bool, error)

    }
    interface GroupVersionAcceptor  {
        + AcceptsGroupVersion(gv schema.GroupVersion) bool

    }
    interface GroupVersionKindProvider  {
        + GroupVersionKind(containingGV schema.GroupVersion) schema.GroupVersionKind

    }
    interface KindProvider  {
        + Kind() string

    }
    interface Lister  {
        + NewList() daemonset.Object
        + List(ctx context.Context, options *internalversion.ListOptions) (daemonset.Object, error)

    }
    interface MayReturnFullObjectDeleter  {
        + DeleteReturnsDeletedObject() bool

    }
    interface NamedCreater  {
        + New() daemonset.Object
        + Create(ctx context.Context, name string, obj daemonset.Object, createValidation ValidateObjectFunc, options *v1.CreateOptions) (daemonset.Object, error)

    }
    interface NamespaceScopedStrategy  {
        + NamespaceScoped() bool

    }
    interface Patcher  {
    }
    interface RESTCreateStrategy  {
        + NamespaceScoped() bool
        + PrepareForCreate(ctx context.Context, obj daemonset.Object) 
        + Validate(ctx context.Context, obj daemonset.Object) field.ErrorList
        + WarningsOnCreate(ctx context.Context, obj daemonset.Object) []string
        + Canonicalize(obj daemonset.Object) 

    }
    interface RESTDeleteStrategy  {
    }
    interface RESTGracefulDeleteStrategy  {
        + CheckGracefulDelete(ctx context.Context, obj daemonset.Object, options *v1.DeleteOptions) bool

    }
    interface RESTUpdateStrategy  {
        + NamespaceScoped() bool
        + AllowCreateOnUpdate() bool
        + PrepareForUpdate(ctx context.Context, obj daemonset.Object, old daemonset.Object) 
        + ValidateUpdate(ctx context.Context, obj daemonset.Object, old daemonset.Object) field.ErrorList
        + WarningsOnUpdate(ctx context.Context, obj daemonset.Object, old daemonset.Object) []string
        + Canonicalize(obj daemonset.Object) 
        + AllowUnconditionalUpdate() bool

    }
    interface Redirector  {
        + ResourceLocation(ctx context.Context, id string) (*url.URL, http.RoundTripper, error)

    }
    interface ResetFieldsStrategy  {
        + GetResetFields() <font color=blue>map</font>[fieldpath.APIVersion]*fieldpath.Set

    }
    interface ResourceStreamer  {
        + InputStream(ctx context.Context, apiVersion string, acceptHeader string) (io.ReadCloser, bool, string, error)

    }
    interface Responder  {
        + Object(statusCode int, obj daemonset.Object) 
        + Error(err error) 

    }
    interface Scoper  {
        + NamespaceScoped() bool

    }
    interface ShortNamesProvider  {
        + ShortNames() []string

    }
    interface SingularNameProvider  {
        + GetSingularName() string

    }
    interface StandardStorage  {
        + Destroy() 

    }
    interface Storage  {
        + New() daemonset.Object
        + Destroy() 

    }
    interface StorageMetadata  {
        + ProducesMIMETypes(verb string) []string
        + ProducesObject(verb string) <font color=blue>interface</font>{}

    }
    interface StorageVersionProvider  {
        + StorageVersion() daemonset.GroupVersioner

    }
    interface TableConvertor  {
        + ConvertToTable(ctx context.Context, object daemonset.Object, tableOptions daemonset.Object) (*v1.Table, error)

    }
    interface UpdateResetFieldsStrategy  {
    }
    interface UpdatedObjectInfo  {
        + Preconditions() *v1.Preconditions
        + UpdatedObject(ctx context.Context, oldObj daemonset.Object) (daemonset.Object, error)

    }
    interface Updater  {
        + New() daemonset.Object
        + Update(ctx context.Context, name string, objInfo UpdatedObjectInfo, createValidation ValidateObjectFunc, updateValidation ValidateObjectUpdateFunc, forceAllowCreate bool, options *v1.UpdateOptions) (daemonset.Object, bool, error)

    }
    interface Watcher  {
        + Watch(ctx context.Context, options *internalversion.ListOptions) (watch.Interface, error)

    }
    class defaultUpdatedObjectInfo << (S,Aquamarine) >> {
        - obj daemonset.Object
        - transformers []TransformFunc

        + Preconditions() *v1.Preconditions
        + UpdatedObject(ctx context.Context, oldObj daemonset.Object) (daemonset.Object, error)

    }
    class daemonset.GarbageCollectionPolicy << (T, #FF7700) >>  {
    }
    class daemonset.TransformFunc << (T, #FF7700) >>  {
    }
    class daemonset.ValidateObjectFunc << (T, #FF7700) >>  {
    }
    class daemonset.ValidateObjectUpdateFunc << (T, #FF7700) >>  {
    }
    class wrappedUpdatedObjectInfo << (S,Aquamarine) >> {
        - objInfo UpdatedObjectInfo
        - transformers []TransformFunc

        + Preconditions() *v1.Preconditions
        + UpdatedObject(ctx context.Context, oldObj daemonset.Object) (daemonset.Object, error)

    }
    class "<font color=blue>func</font>(context.Context, daemonset.Object) error" as fontcolorbluefuncfontcontextContextruntimeObjecterror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(context.Context, daemonset.Object, daemonset.Object) error" as fontcolorbluefuncfontcontextContextruntimeObjectruntimeObjecterror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(context.Context, daemonset.Object, daemonset.Object) (daemonset.Object, error)" as fontcolorbluefuncfontcontextContextruntimeObjectruntimeObjectruntimeObjecterror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"daemonset.RESTCreateUpdateStrategy" *-- "daemonset.CreateUpdateResetFieldsStrategy"
"daemonset.ResetFieldsStrategy" *-- "daemonset.CreateUpdateResetFieldsStrategy"
"daemonset.Creater" *-- "daemonset.CreaterUpdater"
"daemonset.TableConvertor" *-- "daemonset.Lister"
"daemonset.Getter" *-- "daemonset.Patcher"
"daemonset.Updater" *-- "daemonset.Patcher"
"daemonset.CollectionDeleter" *-- "daemonset.StandardStorage"
"daemonset.CreaterUpdater" *-- "daemonset.StandardStorage"
"daemonset.Getter" *-- "daemonset.StandardStorage"
"daemonset.GracefulDeleter" *-- "daemonset.StandardStorage"
"daemonset.Lister" *-- "daemonset.StandardStorage"
"daemonset.Watcher" *-- "daemonset.StandardStorage"
"daemonset.RESTUpdateStrategy" *-- "daemonset.UpdateResetFieldsStrategy"
"daemonset.ResetFieldsStrategy" *-- "daemonset.UpdateResetFieldsStrategy"

"daemonset.UpdatedObjectInfo" <|-- "daemonset.defaultUpdatedObjectInfo"
"daemonset.UpdatedObjectInfo" <|-- "daemonset.wrappedUpdatedObjectInfo"

namespace daemonset {
    interface CacheableObject  {
        + CacheEncode(id Identifier, encode <font color=blue>func</font>(Object, io.Writer) error, w io.Writer) error
        + GetObject() Object

    }
    interface ClientNegotiator  {
        + Encoder(contentType string, params <font color=blue>map</font>[string]string) (Encoder, error)
        + Decoder(contentType string, params <font color=blue>map</font>[string]string) (Decoder, error)
        + StreamDecoder(contentType string, params <font color=blue>map</font>[string]string) (Decoder, Serializer, Framer, error)

    }
    interface Decoder  {
        + Decode(data []byte, defaults *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error)

    }
    interface Encoder  {
        + Encode(obj Object, w io.Writer) error
        + Identifier() Identifier

    }
    interface EncoderWithAllocator  {
        + EncodeWithAllocator(obj Object, w io.Writer, memAlloc MemoryAllocator) error

    }
    interface EquivalentResourceMapper  {
        + EquivalentResourcesFor(resource schema.GroupVersionResource, subresource string) []schema.GroupVersionResource
        + KindFor(resource schema.GroupVersionResource, subresource string) schema.GroupVersionKind

    }
    interface EquivalentResourceRegistry  {
        + RegisterKindFor(resource schema.GroupVersionResource, subresource string, kind schema.GroupVersionKind) 

    }
    interface Framer  {
        + NewFrameReader(r io.ReadCloser) io.ReadCloser
        + NewFrameWriter(w io.Writer) io.Writer

    }
    interface GroupVersioner  {
        + KindForGroupVersionKinds(kinds []schema.GroupVersionKind) (schema.GroupVersionKind, bool)
        + Identifier() string

    }
    interface MemoryAllocator  {
        + Allocate(n uint64) []byte

    }
    interface Namer  {
        + Name(obj Object) (string, error)
        + Namespace(obj Object) (string, error)

    }
    interface NegotiatedSerializer  {
        + SupportedMediaTypes() []SerializerInfo
        + EncoderForVersion(serializer Encoder, gv GroupVersioner) Encoder
        + DecoderToVersion(serializer Decoder, gv GroupVersioner) Decoder

    }
    interface NestedObjectDecoder  {
        + DecodeNestedObjects(d Decoder) error

    }
    interface NestedObjectEncoder  {
        + EncodeNestedObjects(e Encoder) error

    }
    interface Object  {
        + GetObjectKind() schema.ObjectKind
        + DeepCopyObject() Object

    }
    interface ObjectConvertor  {
        + Convert(in <font color=blue>interface</font>{}, out <font color=blue>interface</font>{}, context <font color=blue>interface</font>{}) error
        + ConvertToVersion(in Object, gv GroupVersioner) (Object, error)
        + ConvertFieldLabel(gvk schema.GroupVersionKind, label string, value string) (string, string, error)

    }
    interface ObjectCreater  {
        + New(kind schema.GroupVersionKind) (Object, error)

    }
    interface ObjectDefaulter  {
        + Default(in Object) 

    }
    interface ObjectTyper  {
        + ObjectKinds( Object) ([]schema.GroupVersionKind, bool, error)
        + Recognizes(gvk schema.GroupVersionKind) bool

    }
    interface ObjectVersioner  {
        + ConvertToVersion(in Object, gv GroupVersioner) (Object, error)

    }
    interface ParameterCodec  {
        + DecodeParameters(parameters url.Values, from schema.GroupVersion, into Object) error
        + EncodeParameters(obj Object, to schema.GroupVersion) (url.Values, error)

    }
    interface ResourceVersioner  {
        + SetResourceVersion(obj Object, version string) error
        + ResourceVersion(obj Object) (string, error)

    }
    interface Serializer  {
    }
    class SerializerInfo << (S,Aquamarine) >> {
        + MediaType string
        + MediaTypeType string
        + MediaTypeSubType string
        + EncodesAsText bool
        + Serializer Serializer
        + PrettySerializer Serializer
        + StrictSerializer Serializer
        + StreamSerializer *StreamSerializerInfo

    }
    interface StorageSerializer  {
        + SupportedMediaTypes() []SerializerInfo
        + UniversalDeserializer() Decoder
        + EncoderForVersion(serializer Encoder, gv GroupVersioner) Encoder
        + DecoderToVersion(serializer Decoder, gv GroupVersioner) Decoder

    }
    class StreamSerializerInfo << (S,Aquamarine) >> {
        + EncodesAsText bool

    }
    interface Unstructured  {
        + NewEmptyInstance() Unstructured
        + UnstructuredContent() <font color=blue>map</font>[string]<font color=blue>interface</font>{}
        + SetUnstructuredContent( <font color=blue>map</font>[string]<font color=blue>interface</font>{}) 
        + IsList() bool
        + EachListItem( <font color=blue>func</font>(Object) error) error

    }
    class daemonset.Codec << (T, #FF7700) >>  {
    }
    class daemonset.Identifier << (T, #FF7700) >>  {
    }
}
"daemonset.Encoder" *-- "daemonset.EncoderWithAllocator"
"daemonset.EquivalentResourceMapper" *-- "daemonset.EquivalentResourceRegistry"
"daemonset.Decoder" *-- "daemonset.Serializer"
"daemonset.Encoder" *-- "daemonset.Serializer"
"daemonset.Framer" *-- "daemonset.StreamSerializerInfo"
"daemonset.Serializer" *-- "daemonset.StreamSerializerInfo"
"daemonset.Object" *-- "daemonset.Unstructured"


namespace daemonset {
    class REST << (S,Aquamarine) >> {
        + ShortNames() []string
        + Categories() []string

    }
    class StatusREST << (S,Aquamarine) >> {
        - store *registry.Store

        + New() daemonset.Object
        + Destroy() 
        + Get(ctx context.Context, name string, options *v1.GetOptions) (daemonset.Object, error)
        + Update(ctx context.Context, name string, objInfo daemonset.UpdatedObjectInfo, createValidation daemonset.ValidateObjectFunc, updateValidation daemonset.ValidateObjectUpdateFunc, forceAllowCreate bool, options *v1.UpdateOptions) (daemonset.Object, bool, error)
        + GetResetFields() <font color=blue>map</font>[fieldpath.APIVersion]*fieldpath.Set
        + ConvertToTable(ctx context.Context, object daemonset.Object, tableOptions daemonset.Object) (*v1.Table, error)

    }
}
"registry.Store" *-- "daemonset.REST"

"daemonset.CategoriesProvider" <|-- "daemonset.REST"
"daemonset.ShortNamesProvider" <|-- "daemonset.REST"
"daemonset.CreaterUpdater" <|-- "daemonset.StatusREST"
"daemonset.Getter" <|-- "daemonset.StatusREST"
"daemonset.ResetFieldsStrategy" <|-- "daemonset.StatusREST"
"daemonset.StandardStorage" <|-- "daemonset.StatusREST"
"daemonset.Storage" <|-- "daemonset.StatusREST"
"daemonset.TableConvertor" <|-- "daemonset.StatusREST"
"daemonset.Updater" <|-- "daemonset.StatusREST"

"__builtin__.string" #.. "daemonset.GarbageCollectionPolicy"
"__builtin__.string" #.. "daemonset.Identifier"
"daemonset.fontcolorbluefuncfontcontextContextruntimeObjecterror" #.. "daemonset.ValidateObjectFunc"
"daemonset.fontcolorbluefuncfontcontextContextruntimeObjectruntimeObjectruntimeObjecterror" #.. "daemonset.TransformFunc"
"daemonset.fontcolorbluefuncfontcontextContextruntimeObjectruntimeObjecterror" #.. "daemonset.ValidateObjectUpdateFunc"
"daemonset.Serializer" #.. "daemonset.Codec"
@enduml
