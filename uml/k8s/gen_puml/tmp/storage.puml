@startuml
namespace storage {
    class authenticatedDataString << (S,Aquamarine) >> {
        + AuthenticatedData() []byte

    }
    class storage.authenticatedDataString << (T, #FF7700) >>  {
    }
    class objState << (S,Aquamarine) >> {
        - obj runtime.Object
        - meta *storage.ResponseMeta
        - rev int64
        - data []byte
        - stale bool

    }
    class store << (S,Aquamarine) >> {
        - client *v3.Client
        - codec runtime.Codec
        - versioner storage.Versioner
        - transformer value.Transformer
        - pathPrefix string
        - groupResource schema.GroupResource
        - groupResourceString string
        - watcher *watcher
        - pagingEnabled bool
        - leaseManager *leaseManager

        - conditionalDelete(ctx context.Context, key string, out runtime.Object, v reflect.Value, preconditions *storage.Preconditions, validateDeletion storage.ValidateObjectFunc, cachedExistingObject runtime.Object) error
        - getState(ctx context.Context, getResp *v3.GetResponse, key string, v reflect.Value, ignoreNotFound bool) (*objState, error)
        - getStateFromObject(obj runtime.Object) (*objState, error)
        - updateState(st *objState, userUpdate storage.UpdateFunc) (runtime.Object, uint64, error)
        - ttlOpts(ctx context.Context, ttl int64) ([]v3.OpOption, error)
        - validateMinimumResourceVersion(minimumResourceVersion string, actualRevision uint64) error
        - prepareKey(key string) (string, error)

        + Versioner() storage.Versioner
        + Get(ctx context.Context, key string, opts storage.GetOptions, out runtime.Object) error
        + Create(ctx context.Context, key string, obj runtime.Object, out runtime.Object, ttl uint64) error
        + Delete(ctx context.Context, key string, out runtime.Object, preconditions *storage.Preconditions, validateDeletion storage.ValidateObjectFunc, cachedExistingObject runtime.Object) error
        + GuaranteedUpdate(ctx context.Context, key string, destination runtime.Object, ignoreNotFound bool, preconditions *storage.Preconditions, tryUpdate storage.UpdateFunc, cachedExistingObject runtime.Object) error
        + Count(key string) (int64, error)
        + GetList(ctx context.Context, key string, opts storage.ListOptions, listObj runtime.Object) error
        + Watch(ctx context.Context, key string, opts storage.ListOptions) (watch.Interface, error)

    }
}

"storage.Interface" <|-- "storage.store"

namespace storage {
    class DryRunnableStorage << (S,Aquamarine) >> {
        + Storage storage.Interface
        + Codec runtime.Codec

        - copyInto(in runtime.Object, out runtime.Object) error

        + Versioner() storage.Versioner
        + Create(ctx context.Context, key string, obj runtime.Object, out runtime.Object, ttl uint64, dryRun bool) error
        + Delete(ctx context.Context, key string, out runtime.Object, preconditions *storage.Preconditions, deleteValidation storage.ValidateObjectFunc, dryRun bool, cachedExistingObject runtime.Object) error
        + Watch(ctx context.Context, key string, opts storage.ListOptions) (watch.Interface, error)
        + Get(ctx context.Context, key string, opts storage.GetOptions, objPtr runtime.Object) error
        + GetList(ctx context.Context, key string, opts storage.ListOptions, listObj runtime.Object) error
        + GuaranteedUpdate(ctx context.Context, key string, destination runtime.Object, ignoreNotFound bool, preconditions *storage.Preconditions, tryUpdate storage.UpdateFunc, dryRun bool, cachedExistingObject runtime.Object) error
        + Count(key string) (int64, error)

    }
}


namespace storage {
    class GetOptions << (S,Aquamarine) >> {
        + IgnoreNotFound bool
        + ResourceVersion string

    }
    interface Interface  {
        + Versioner() Versioner
        + Create(ctx context.Context, key string, obj runtime.Object, out runtime.Object, ttl uint64) error
        + Delete(ctx context.Context, key string, out runtime.Object, preconditions *Preconditions, validateDeletion ValidateObjectFunc, cachedExistingObject runtime.Object) error
        + Watch(ctx context.Context, key string, opts ListOptions) (watch.Interface, error)
        + Get(ctx context.Context, key string, opts GetOptions, objPtr runtime.Object) error
        + GetList(ctx context.Context, key string, opts ListOptions, listObj runtime.Object) error
        + GuaranteedUpdate(ctx context.Context, key string, destination runtime.Object, ignoreNotFound bool, preconditions *Preconditions, tryUpdate UpdateFunc, cachedExistingObject runtime.Object) error
        + Count(key string) (int64, error)

    }
    class ListOptions << (S,Aquamarine) >> {
        + ResourceVersion string
        + ResourceVersionMatch v1.ResourceVersionMatch
        + Predicate SelectionPredicate
        + Recursive bool
        + ProgressNotify bool

    }
    class MatchValue << (S,Aquamarine) >> {
        + IndexName string
        + Value string

    }
    class Preconditions << (S,Aquamarine) >> {
        + UID *types.UID
        + ResourceVersion *string

        + Check(key string, obj runtime.Object) error

    }
    class ResponseMeta << (S,Aquamarine) >> {
        + TTL int64
        + ResourceVersion uint64

    }
    interface Versioner  {
        + UpdateObject(obj runtime.Object, resourceVersion uint64) error
        + UpdateList(obj runtime.Object, resourceVersion uint64, continueValue string, remainingItemCount *int64) error
        + PrepareObjectForStorage(obj runtime.Object) error
        + ObjectResourceVersion(obj runtime.Object) (uint64, error)
        + ParseResourceVersion(resourceVersion string) (uint64, error)

    }
    class storage.IndexerFunc << (T, #FF7700) >>  {
    }
    class storage.IndexerFuncs << (T, #FF7700) >>  {
    }
    class storage.UpdateFunc << (T, #FF7700) >>  {
    }
    class storage.ValidateObjectFunc << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>(context.Context, runtime.Object) error" as fontcolorbluefuncfontcontextContextruntimeObjecterror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(runtime.Object, ResponseMeta) (runtime.Object, *uint64, error)" as fontcolorbluefuncfontruntimeObjectResponseMetaruntimeObjectuint64error {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(runtime.Object) string" as fontcolorbluefuncfontruntimeObjectstring {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


"__builtin__.string" #.. "storage.authenticatedDataString"
"storage.fontcolorbluefuncfontcontextContextruntimeObjecterror" #.. "storage.ValidateObjectFunc"
"storage.fontcolorbluefuncfontruntimeObjectstring" #.. "storage.IndexerFunc"
"storage.fontcolorbluefuncfontruntimeObjectResponseMetaruntimeObjectuint64error" #.. "storage.UpdateFunc"
"storage.<font color=blue>map</font>[string]IndexerFunc" #.. "storage.IndexerFuncs"
@enduml
