@startuml
namespace abac {
    class Policy << (S,Aquamarine) >> {
        + Spec PolicySpec

        + DeepCopyInto(out *Policy) 
        + DeepCopy() *Policy
        + DeepCopyObject() runtime.Object

    }
    class PolicySpec << (S,Aquamarine) >> {
        + User string
        + Group string
        + Readonly bool
        + APIGroup string
        + Resource string
        + Namespace string
        + NonResourcePath string

        + DeepCopyInto(out *PolicySpec) 
        + DeepCopy() *PolicySpec

    }
}
"v1.TypeMeta" *-- "abac.Policy"


namespace admission {
    class AdmissionRequest << (S,Aquamarine) >> {
        + UID types.UID
        + Kind v1.GroupVersionKind
        + Resource v1.GroupVersionResource
        + SubResource string
        + RequestKind *v1.GroupVersionKind
        + RequestResource *v1.GroupVersionResource
        + RequestSubResource string
        + Name string
        + Namespace string
        + Operation Operation
        + UserInfo authentication.UserInfo
        + Object runtime.Object
        + OldObject runtime.Object
        + DryRun *bool
        + Options runtime.Object

        + DeepCopyInto(out *AdmissionRequest) 
        + DeepCopy() *AdmissionRequest

    }
    class AdmissionResponse << (S,Aquamarine) >> {
        + UID types.UID
        + Allowed bool
        + Result *v1.Status
        + Patch []byte
        + PatchType *PatchType
        + AuditAnnotations <font color=blue>map</font>[string]string
        + Warnings []string

        + DeepCopyInto(out *AdmissionResponse) 
        + DeepCopy() *AdmissionResponse

    }
    class AdmissionReview << (S,Aquamarine) >> {
        + Request *AdmissionRequest
        + Response *AdmissionResponse

        + DeepCopyInto(out *AdmissionReview) 
        + DeepCopy() *AdmissionReview
        + DeepCopyObject() runtime.Object

    }
    class admission.Operation << (T, #FF7700) >>  {
    }
    class admission.PatchType << (T, #FF7700) >>  {
    }
}
"v1.TypeMeta" *-- "admission.AdmissionReview"


namespace admissionregistration {
    class MatchResources << (S,Aquamarine) >> {
        + NamespaceSelector *v1.LabelSelector
        + ObjectSelector *v1.LabelSelector
        + ResourceRules []NamedRuleWithOperations
        + ExcludeResourceRules []NamedRuleWithOperations
        + MatchPolicy *MatchPolicyType

        + DeepCopyInto(out *MatchResources) 
        + DeepCopy() *MatchResources

    }
    class MutatingWebhook << (S,Aquamarine) >> {
        + Name string
        + ClientConfig WebhookClientConfig
        + Rules []RuleWithOperations
        + FailurePolicy *FailurePolicyType
        + MatchPolicy *MatchPolicyType
        + NamespaceSelector *v1.LabelSelector
        + ObjectSelector *v1.LabelSelector
        + SideEffects *SideEffectClass
        + TimeoutSeconds *int32
        + AdmissionReviewVersions []string
        + ReinvocationPolicy *ReinvocationPolicyType

        + DeepCopyInto(out *MutatingWebhook) 
        + DeepCopy() *MutatingWebhook

    }
    class MutatingWebhookConfiguration << (S,Aquamarine) >> {
        + Webhooks []MutatingWebhook

        + DeepCopyInto(out *MutatingWebhookConfiguration) 
        + DeepCopy() *MutatingWebhookConfiguration
        + DeepCopyObject() runtime.Object

    }
    class MutatingWebhookConfigurationList << (S,Aquamarine) >> {
        + Items []MutatingWebhookConfiguration

        + DeepCopyInto(out *MutatingWebhookConfigurationList) 
        + DeepCopy() *MutatingWebhookConfigurationList
        + DeepCopyObject() runtime.Object

    }
    class NamedRuleWithOperations << (S,Aquamarine) >> {
        + ResourceNames []string
        + RuleWithOperations RuleWithOperations

        + DeepCopyInto(out *NamedRuleWithOperations) 
        + DeepCopy() *NamedRuleWithOperations

    }
    class ParamKind << (S,Aquamarine) >> {
        + APIVersion string
        + Kind string

        + DeepCopyInto(out *ParamKind) 
        + DeepCopy() *ParamKind

    }
    class ParamRef << (S,Aquamarine) >> {
        + Name string
        + Namespace string

        + DeepCopyInto(out *ParamRef) 
        + DeepCopy() *ParamRef

    }
    class Rule << (S,Aquamarine) >> {
        + APIGroups []string
        + APIVersions []string
        + Resources []string
        + Scope *ScopeType

        + DeepCopyInto(out *Rule) 
        + DeepCopy() *Rule

    }
    class RuleWithOperations << (S,Aquamarine) >> {
        + Operations []OperationType

        + DeepCopyInto(out *RuleWithOperations) 
        + DeepCopy() *RuleWithOperations

    }
    class ServiceReference << (S,Aquamarine) >> {
        + Namespace string
        + Name string
        + Path *string
        + Port int32

        + DeepCopyInto(out *ServiceReference) 
        + DeepCopy() *ServiceReference

    }
    class ValidatingAdmissionPolicy << (S,Aquamarine) >> {
        + Spec ValidatingAdmissionPolicySpec

        + DeepCopyInto(out *ValidatingAdmissionPolicy) 
        + DeepCopy() *ValidatingAdmissionPolicy
        + DeepCopyObject() runtime.Object

    }
    class ValidatingAdmissionPolicyBinding << (S,Aquamarine) >> {
        + Spec ValidatingAdmissionPolicyBindingSpec

        + DeepCopyInto(out *ValidatingAdmissionPolicyBinding) 
        + DeepCopy() *ValidatingAdmissionPolicyBinding
        + DeepCopyObject() runtime.Object

    }
    class ValidatingAdmissionPolicyBindingList << (S,Aquamarine) >> {
        + Items []ValidatingAdmissionPolicyBinding

        + DeepCopyInto(out *ValidatingAdmissionPolicyBindingList) 
        + DeepCopy() *ValidatingAdmissionPolicyBindingList
        + DeepCopyObject() runtime.Object

    }
    class ValidatingAdmissionPolicyBindingSpec << (S,Aquamarine) >> {
        + PolicyName string
        + ParamRef *ParamRef
        + MatchResources *MatchResources

        + DeepCopyInto(out *ValidatingAdmissionPolicyBindingSpec) 
        + DeepCopy() *ValidatingAdmissionPolicyBindingSpec

    }
    class ValidatingAdmissionPolicyList << (S,Aquamarine) >> {
        + Items []ValidatingAdmissionPolicy

        + DeepCopyInto(out *ValidatingAdmissionPolicyList) 
        + DeepCopy() *ValidatingAdmissionPolicyList
        + DeepCopyObject() runtime.Object

    }
    class ValidatingAdmissionPolicySpec << (S,Aquamarine) >> {
        + ParamKind *ParamKind
        + MatchConstraints *MatchResources
        + Validations []Validation
        + FailurePolicy *FailurePolicyType

        + DeepCopyInto(out *ValidatingAdmissionPolicySpec) 
        + DeepCopy() *ValidatingAdmissionPolicySpec

    }
    class ValidatingWebhook << (S,Aquamarine) >> {
        + Name string
        + ClientConfig WebhookClientConfig
        + Rules []RuleWithOperations
        + FailurePolicy *FailurePolicyType
        + MatchPolicy *MatchPolicyType
        + NamespaceSelector *v1.LabelSelector
        + ObjectSelector *v1.LabelSelector
        + SideEffects *SideEffectClass
        + TimeoutSeconds *int32
        + AdmissionReviewVersions []string

        + DeepCopyInto(out *ValidatingWebhook) 
        + DeepCopy() *ValidatingWebhook

    }
    class ValidatingWebhookConfiguration << (S,Aquamarine) >> {
        + Webhooks []ValidatingWebhook

        + DeepCopyInto(out *ValidatingWebhookConfiguration) 
        + DeepCopy() *ValidatingWebhookConfiguration
        + DeepCopyObject() runtime.Object

    }
    class ValidatingWebhookConfigurationList << (S,Aquamarine) >> {
        + Items []ValidatingWebhookConfiguration

        + DeepCopyInto(out *ValidatingWebhookConfigurationList) 
        + DeepCopy() *ValidatingWebhookConfigurationList
        + DeepCopyObject() runtime.Object

    }
    class Validation << (S,Aquamarine) >> {
        + Expression string
        + Message string
        + Reason *v1.StatusReason

        + DeepCopyInto(out *Validation) 
        + DeepCopy() *Validation

    }
    class WebhookClientConfig << (S,Aquamarine) >> {
        + URL *string
        + Service *ServiceReference
        + CABundle []byte

        + DeepCopyInto(out *WebhookClientConfig) 
        + DeepCopy() *WebhookClientConfig

    }
    class admissionregistration.FailurePolicyType << (T, #FF7700) >>  {
    }
    class admissionregistration.MatchPolicyType << (T, #FF7700) >>  {
    }
    class admissionregistration.OperationType << (T, #FF7700) >>  {
    }
    class admissionregistration.ReinvocationPolicyType << (T, #FF7700) >>  {
    }
    class admissionregistration.ScopeType << (T, #FF7700) >>  {
    }
    class admissionregistration.SideEffectClass << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "admissionregistration.MutatingWebhookConfiguration"
"v1.TypeMeta" *-- "admissionregistration.MutatingWebhookConfiguration"
"v1.ListMeta" *-- "admissionregistration.MutatingWebhookConfigurationList"
"v1.TypeMeta" *-- "admissionregistration.MutatingWebhookConfigurationList"
"admissionregistration.Rule" *-- "admissionregistration.RuleWithOperations"
"v1.ObjectMeta" *-- "admissionregistration.ValidatingAdmissionPolicy"
"v1.TypeMeta" *-- "admissionregistration.ValidatingAdmissionPolicy"
"v1.ObjectMeta" *-- "admissionregistration.ValidatingAdmissionPolicyBinding"
"v1.TypeMeta" *-- "admissionregistration.ValidatingAdmissionPolicyBinding"
"v1.ListMeta" *-- "admissionregistration.ValidatingAdmissionPolicyBindingList"
"v1.TypeMeta" *-- "admissionregistration.ValidatingAdmissionPolicyBindingList"
"v1.ListMeta" *-- "admissionregistration.ValidatingAdmissionPolicyList"
"v1.TypeMeta" *-- "admissionregistration.ValidatingAdmissionPolicyList"
"v1.ObjectMeta" *-- "admissionregistration.ValidatingWebhookConfiguration"
"v1.TypeMeta" *-- "admissionregistration.ValidatingWebhookConfiguration"
"v1.ListMeta" *-- "admissionregistration.ValidatingWebhookConfigurationList"
"v1.TypeMeta" *-- "admissionregistration.ValidatingWebhookConfigurationList"


namespace apidiscovery {
    class APIGroupDiscovery << (S,Aquamarine) >> {
        + Versions []APIVersionDiscovery

        + DeepCopyInto(out *APIGroupDiscovery) 
        + DeepCopy() *APIGroupDiscovery
        + DeepCopyObject() runtime.Object

    }
    class APIGroupDiscoveryList << (S,Aquamarine) >> {
        + Items []APIGroupDiscovery

        + DeepCopyInto(out *APIGroupDiscoveryList) 
        + DeepCopy() *APIGroupDiscoveryList
        + DeepCopyObject() runtime.Object

    }
    class APIResourceDiscovery << (S,Aquamarine) >> {
        + Resource string
        + ResponseKind *v1.GroupVersionKind
        + Scope ResourceScope
        + SingularResource string
        + Verbs []string
        + ShortNames []string
        + Categories []string
        + Subresources []APISubresourceDiscovery

        + DeepCopyInto(out *APIResourceDiscovery) 
        + DeepCopy() *APIResourceDiscovery

    }
    class APISubresourceDiscovery << (S,Aquamarine) >> {
        + Subresource string
        + ResponseKind *v1.GroupVersionKind
        + AcceptedTypes []v1.GroupVersionKind
        + Verbs []string

        + DeepCopyInto(out *APISubresourceDiscovery) 
        + DeepCopy() *APISubresourceDiscovery

    }
    class APIVersionDiscovery << (S,Aquamarine) >> {
        + Version string
        + Resources []APIResourceDiscovery
        + Freshness DiscoveryFreshness

        + DeepCopyInto(out *APIVersionDiscovery) 
        + DeepCopy() *APIVersionDiscovery

    }
    class apidiscovery.DiscoveryFreshness << (T, #FF7700) >>  {
    }
    class apidiscovery.ResourceScope << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "apidiscovery.APIGroupDiscovery"
"v1.TypeMeta" *-- "apidiscovery.APIGroupDiscovery"
"v1.ListMeta" *-- "apidiscovery.APIGroupDiscoveryList"
"v1.TypeMeta" *-- "apidiscovery.APIGroupDiscoveryList"


namespace apiserverinternal {
    class ServerStorageVersion << (S,Aquamarine) >> {
        + APIServerID string
        + EncodingVersion string
        + DecodableVersions []string

        + DeepCopyInto(out *ServerStorageVersion) 
        + DeepCopy() *ServerStorageVersion

    }
    class StorageVersion << (S,Aquamarine) >> {
        + Spec StorageVersionSpec
        + Status StorageVersionStatus

        + DeepCopyInto(out *StorageVersion) 
        + DeepCopy() *StorageVersion
        + DeepCopyObject() runtime.Object

    }
    class StorageVersionCondition << (S,Aquamarine) >> {
        + Type StorageVersionConditionType
        + Status ConditionStatus
        + ObservedGeneration int64
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *StorageVersionCondition) 
        + DeepCopy() *StorageVersionCondition

    }
    class StorageVersionList << (S,Aquamarine) >> {
        + Items []StorageVersion

        + DeepCopyInto(out *StorageVersionList) 
        + DeepCopy() *StorageVersionList
        + DeepCopyObject() runtime.Object

    }
    class StorageVersionSpec << (S,Aquamarine) >> {
        + DeepCopyInto(out *StorageVersionSpec) 
        + DeepCopy() *StorageVersionSpec

    }
    class StorageVersionStatus << (S,Aquamarine) >> {
        + StorageVersions []ServerStorageVersion
        + CommonEncodingVersion *string
        + Conditions []StorageVersionCondition

        + DeepCopyInto(out *StorageVersionStatus) 
        + DeepCopy() *StorageVersionStatus

    }
    class apiserverinternal.ConditionStatus << (T, #FF7700) >>  {
    }
    class apiserverinternal.StorageVersionConditionType << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "apiserverinternal.StorageVersion"
"v1.TypeMeta" *-- "apiserverinternal.StorageVersion"
"v1.ListMeta" *-- "apiserverinternal.StorageVersionList"
"v1.TypeMeta" *-- "apiserverinternal.StorageVersionList"


namespace apps {
    class ControllerRevision << (S,Aquamarine) >> {
        + Data runtime.Object
        + Revision int64

        + DeepCopyInto(out *ControllerRevision) 
        + DeepCopy() *ControllerRevision
        + DeepCopyObject() runtime.Object

    }
    class ControllerRevisionList << (S,Aquamarine) >> {
        + Items []ControllerRevision

        + DeepCopyInto(out *ControllerRevisionList) 
        + DeepCopy() *ControllerRevisionList
        + DeepCopyObject() runtime.Object

    }
    class DaemonSet << (S,Aquamarine) >> {
        + Spec DaemonSetSpec
        + Status DaemonSetStatus

        + DeepCopyInto(out *DaemonSet) 
        + DeepCopy() *DaemonSet
        + DeepCopyObject() runtime.Object

    }
    class DaemonSetCondition << (S,Aquamarine) >> {
        + Type DaemonSetConditionType
        + Status core.ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *DaemonSetCondition) 
        + DeepCopy() *DaemonSetCondition

    }
    class DaemonSetList << (S,Aquamarine) >> {
        + Items []DaemonSet

        + DeepCopyInto(out *DaemonSetList) 
        + DeepCopy() *DaemonSetList
        + DeepCopyObject() runtime.Object

    }
    class DaemonSetSpec << (S,Aquamarine) >> {
        + Selector *v1.LabelSelector
        + Template core.PodTemplateSpec
        + UpdateStrategy DaemonSetUpdateStrategy
        + MinReadySeconds int32
        + TemplateGeneration int64
        + RevisionHistoryLimit *int32

        + DeepCopyInto(out *DaemonSetSpec) 
        + DeepCopy() *DaemonSetSpec

    }
    class DaemonSetStatus << (S,Aquamarine) >> {
        + CurrentNumberScheduled int32
        + NumberMisscheduled int32
        + DesiredNumberScheduled int32
        + NumberReady int32
        + ObservedGeneration int64
        + UpdatedNumberScheduled int32
        + NumberAvailable int32
        + NumberUnavailable int32
        + CollisionCount *int32
        + Conditions []DaemonSetCondition

        + DeepCopyInto(out *DaemonSetStatus) 
        + DeepCopy() *DaemonSetStatus

    }
    class DaemonSetUpdateStrategy << (S,Aquamarine) >> {
        + Type DaemonSetUpdateStrategyType
        + RollingUpdate *RollingUpdateDaemonSet

        + DeepCopyInto(out *DaemonSetUpdateStrategy) 
        + DeepCopy() *DaemonSetUpdateStrategy

    }
    class Deployment << (S,Aquamarine) >> {
        + Spec DeploymentSpec
        + Status DeploymentStatus

        + DeepCopyInto(out *Deployment) 
        + DeepCopy() *Deployment
        + DeepCopyObject() runtime.Object

    }
    class DeploymentCondition << (S,Aquamarine) >> {
        + Type DeploymentConditionType
        + Status core.ConditionStatus
        + LastUpdateTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *DeploymentCondition) 
        + DeepCopy() *DeploymentCondition

    }
    class DeploymentList << (S,Aquamarine) >> {
        + Items []Deployment

        + DeepCopyInto(out *DeploymentList) 
        + DeepCopy() *DeploymentList
        + DeepCopyObject() runtime.Object

    }
    class DeploymentRollback << (S,Aquamarine) >> {
        + Name string
        + UpdatedAnnotations <font color=blue>map</font>[string]string
        + RollbackTo RollbackConfig

        + DeepCopyInto(out *DeploymentRollback) 
        + DeepCopy() *DeploymentRollback
        + DeepCopyObject() runtime.Object

    }
    class DeploymentSpec << (S,Aquamarine) >> {
        + Replicas int32
        + Selector *v1.LabelSelector
        + Template core.PodTemplateSpec
        + Strategy DeploymentStrategy
        + MinReadySeconds int32
        + RevisionHistoryLimit *int32
        + Paused bool
        + RollbackTo *RollbackConfig
        + ProgressDeadlineSeconds *int32

        + DeepCopyInto(out *DeploymentSpec) 
        + DeepCopy() *DeploymentSpec

    }
    class DeploymentStatus << (S,Aquamarine) >> {
        + ObservedGeneration int64
        + Replicas int32
        + UpdatedReplicas int32
        + ReadyReplicas int32
        + AvailableReplicas int32
        + UnavailableReplicas int32
        + Conditions []DeploymentCondition
        + CollisionCount *int32

        + DeepCopyInto(out *DeploymentStatus) 
        + DeepCopy() *DeploymentStatus

    }
    class DeploymentStrategy << (S,Aquamarine) >> {
        + Type DeploymentStrategyType
        + RollingUpdate *RollingUpdateDeployment

        + DeepCopyInto(out *DeploymentStrategy) 
        + DeepCopy() *DeploymentStrategy

    }
    class ReplicaSet << (S,Aquamarine) >> {
        + Spec ReplicaSetSpec
        + Status ReplicaSetStatus

        + DeepCopyInto(out *ReplicaSet) 
        + DeepCopy() *ReplicaSet
        + DeepCopyObject() runtime.Object

    }
    class ReplicaSetCondition << (S,Aquamarine) >> {
        + Type ReplicaSetConditionType
        + Status core.ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *ReplicaSetCondition) 
        + DeepCopy() *ReplicaSetCondition

    }
    class ReplicaSetList << (S,Aquamarine) >> {
        + Items []ReplicaSet

        + DeepCopyInto(out *ReplicaSetList) 
        + DeepCopy() *ReplicaSetList
        + DeepCopyObject() runtime.Object

    }
    class ReplicaSetSpec << (S,Aquamarine) >> {
        + Replicas int32
        + MinReadySeconds int32
        + Selector *v1.LabelSelector
        + Template core.PodTemplateSpec

        + DeepCopyInto(out *ReplicaSetSpec) 
        + DeepCopy() *ReplicaSetSpec

    }
    class ReplicaSetStatus << (S,Aquamarine) >> {
        + Replicas int32
        + FullyLabeledReplicas int32
        + ReadyReplicas int32
        + AvailableReplicas int32
        + ObservedGeneration int64
        + Conditions []ReplicaSetCondition

        + DeepCopyInto(out *ReplicaSetStatus) 
        + DeepCopy() *ReplicaSetStatus

    }
    class RollbackConfig << (S,Aquamarine) >> {
        + Revision int64

        + DeepCopyInto(out *RollbackConfig) 
        + DeepCopy() *RollbackConfig

    }
    class RollingUpdateDaemonSet << (S,Aquamarine) >> {
        + MaxUnavailable intstr.IntOrString
        + MaxSurge intstr.IntOrString

        + DeepCopyInto(out *RollingUpdateDaemonSet) 
        + DeepCopy() *RollingUpdateDaemonSet

    }
    class RollingUpdateDeployment << (S,Aquamarine) >> {
        + MaxUnavailable intstr.IntOrString
        + MaxSurge intstr.IntOrString

        + DeepCopyInto(out *RollingUpdateDeployment) 
        + DeepCopy() *RollingUpdateDeployment

    }
    class RollingUpdateStatefulSetStrategy << (S,Aquamarine) >> {
        + Partition int32
        + MaxUnavailable *intstr.IntOrString

        + DeepCopyInto(out *RollingUpdateStatefulSetStrategy) 
        + DeepCopy() *RollingUpdateStatefulSetStrategy

    }
    class StatefulSet << (S,Aquamarine) >> {
        + Spec StatefulSetSpec
        + Status StatefulSetStatus

        + DeepCopyInto(out *StatefulSet) 
        + DeepCopy() *StatefulSet
        + DeepCopyObject() runtime.Object

    }
    class StatefulSetCondition << (S,Aquamarine) >> {
        + Type StatefulSetConditionType
        + Status core.ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *StatefulSetCondition) 
        + DeepCopy() *StatefulSetCondition

    }
    class StatefulSetList << (S,Aquamarine) >> {
        + Items []StatefulSet

        + DeepCopyInto(out *StatefulSetList) 
        + DeepCopy() *StatefulSetList
        + DeepCopyObject() runtime.Object

    }
    class StatefulSetOrdinals << (S,Aquamarine) >> {
        + Start int32

        + DeepCopyInto(out *StatefulSetOrdinals) 
        + DeepCopy() *StatefulSetOrdinals

    }
    class StatefulSetPersistentVolumeClaimRetentionPolicy << (S,Aquamarine) >> {
        + WhenDeleted PersistentVolumeClaimRetentionPolicyType
        + WhenScaled PersistentVolumeClaimRetentionPolicyType

        + DeepCopyInto(out *StatefulSetPersistentVolumeClaimRetentionPolicy) 
        + DeepCopy() *StatefulSetPersistentVolumeClaimRetentionPolicy

    }
    class StatefulSetSpec << (S,Aquamarine) >> {
        + Replicas int32
        + Selector *v1.LabelSelector
        + Template core.PodTemplateSpec
        + VolumeClaimTemplates []core.PersistentVolumeClaim
        + ServiceName string
        + PodManagementPolicy PodManagementPolicyType
        + UpdateStrategy StatefulSetUpdateStrategy
        + RevisionHistoryLimit *int32
        + MinReadySeconds int32
        + PersistentVolumeClaimRetentionPolicy *StatefulSetPersistentVolumeClaimRetentionPolicy
        + Ordinals *StatefulSetOrdinals

        + DeepCopyInto(out *StatefulSetSpec) 
        + DeepCopy() *StatefulSetSpec

    }
    class StatefulSetStatus << (S,Aquamarine) >> {
        + ObservedGeneration *int64
        + Replicas int32
        + ReadyReplicas int32
        + CurrentReplicas int32
        + UpdatedReplicas int32
        + CurrentRevision string
        + UpdateRevision string
        + CollisionCount *int32
        + Conditions []StatefulSetCondition
        + AvailableReplicas int32

        + DeepCopyInto(out *StatefulSetStatus) 
        + DeepCopy() *StatefulSetStatus

    }
    class StatefulSetUpdateStrategy << (S,Aquamarine) >> {
        + Type StatefulSetUpdateStrategyType
        + RollingUpdate *RollingUpdateStatefulSetStrategy

        + DeepCopyInto(out *StatefulSetUpdateStrategy) 
        + DeepCopy() *StatefulSetUpdateStrategy

    }
    class apps.DaemonSetConditionType << (T, #FF7700) >>  {
    }
    class apps.DaemonSetUpdateStrategyType << (T, #FF7700) >>  {
    }
    class apps.DeploymentConditionType << (T, #FF7700) >>  {
    }
    class apps.DeploymentStrategyType << (T, #FF7700) >>  {
    }
    class apps.PersistentVolumeClaimRetentionPolicyType << (T, #FF7700) >>  {
    }
    class apps.PodManagementPolicyType << (T, #FF7700) >>  {
    }
    class apps.ReplicaSetConditionType << (T, #FF7700) >>  {
    }
    class apps.StatefulSetConditionType << (T, #FF7700) >>  {
    }
    class apps.StatefulSetUpdateStrategyType << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "apps.ControllerRevision"
"v1.TypeMeta" *-- "apps.ControllerRevision"
"v1.ListMeta" *-- "apps.ControllerRevisionList"
"v1.TypeMeta" *-- "apps.ControllerRevisionList"
"v1.ObjectMeta" *-- "apps.DaemonSet"
"v1.TypeMeta" *-- "apps.DaemonSet"
"v1.ListMeta" *-- "apps.DaemonSetList"
"v1.TypeMeta" *-- "apps.DaemonSetList"
"v1.ObjectMeta" *-- "apps.Deployment"
"v1.TypeMeta" *-- "apps.Deployment"
"v1.ListMeta" *-- "apps.DeploymentList"
"v1.TypeMeta" *-- "apps.DeploymentList"
"v1.TypeMeta" *-- "apps.DeploymentRollback"
"v1.ObjectMeta" *-- "apps.ReplicaSet"
"v1.TypeMeta" *-- "apps.ReplicaSet"
"v1.ListMeta" *-- "apps.ReplicaSetList"
"v1.TypeMeta" *-- "apps.ReplicaSetList"
"v1.ObjectMeta" *-- "apps.StatefulSet"
"v1.TypeMeta" *-- "apps.StatefulSet"
"v1.ListMeta" *-- "apps.StatefulSetList"
"v1.TypeMeta" *-- "apps.StatefulSetList"


namespace authentication {
    class BoundObjectReference << (S,Aquamarine) >> {
        + Kind string
        + APIVersion string
        + Name string
        + UID types.UID

        + DeepCopyInto(out *BoundObjectReference) 
        + DeepCopy() *BoundObjectReference

    }
    class ExtraValue << (S,Aquamarine) >> {
        + DeepCopyInto(out *ExtraValue) 
        + DeepCopy() ExtraValue

    }
    class SelfSubjectReview << (S,Aquamarine) >> {
        + Status SelfSubjectReviewStatus

        + DeepCopyInto(out *SelfSubjectReview) 
        + DeepCopy() *SelfSubjectReview
        + DeepCopyObject() runtime.Object

    }
    class SelfSubjectReviewStatus << (S,Aquamarine) >> {
        + UserInfo UserInfo

        + DeepCopyInto(out *SelfSubjectReviewStatus) 
        + DeepCopy() *SelfSubjectReviewStatus

    }
    class TokenRequest << (S,Aquamarine) >> {
        + Spec TokenRequestSpec
        + Status TokenRequestStatus

        + DeepCopyInto(out *TokenRequest) 
        + DeepCopy() *TokenRequest
        + DeepCopyObject() runtime.Object

    }
    class TokenRequestSpec << (S,Aquamarine) >> {
        + Audiences []string
        + ExpirationSeconds int64
        + BoundObjectRef *BoundObjectReference

        + DeepCopyInto(out *TokenRequestSpec) 
        + DeepCopy() *TokenRequestSpec

    }
    class TokenRequestStatus << (S,Aquamarine) >> {
        + Token string
        + ExpirationTimestamp v1.Time

        + DeepCopyInto(out *TokenRequestStatus) 
        + DeepCopy() *TokenRequestStatus

    }
    class TokenReview << (S,Aquamarine) >> {
        + Spec TokenReviewSpec
        + Status TokenReviewStatus

        + DeepCopyInto(out *TokenReview) 
        + DeepCopy() *TokenReview
        + DeepCopyObject() runtime.Object

    }
    class TokenReviewSpec << (S,Aquamarine) >> {
        + Token string
        + Audiences []string

        + DeepCopyInto(out *TokenReviewSpec) 
        + DeepCopy() *TokenReviewSpec

    }
    class TokenReviewStatus << (S,Aquamarine) >> {
        + Authenticated bool
        + User UserInfo
        + Audiences []string
        + Error string

        + DeepCopyInto(out *TokenReviewStatus) 
        + DeepCopy() *TokenReviewStatus

    }
    class UserInfo << (S,Aquamarine) >> {
        + Username string
        + UID string
        + Groups []string
        + Extra <font color=blue>map</font>[string]ExtraValue

        + DeepCopyInto(out *UserInfo) 
        + DeepCopy() *UserInfo

    }
    class authentication.ExtraValue << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "authentication.SelfSubjectReview"
"v1.TypeMeta" *-- "authentication.SelfSubjectReview"
"v1.ObjectMeta" *-- "authentication.TokenRequest"
"v1.TypeMeta" *-- "authentication.TokenRequest"
"v1.ObjectMeta" *-- "authentication.TokenReview"
"v1.TypeMeta" *-- "authentication.TokenReview"


namespace authorization {
    class ExtraValue << (S,Aquamarine) >> {
        + DeepCopyInto(out *ExtraValue) 
        + DeepCopy() ExtraValue

    }
    class LocalSubjectAccessReview << (S,Aquamarine) >> {
        + Spec SubjectAccessReviewSpec
        + Status SubjectAccessReviewStatus

        + DeepCopyInto(out *LocalSubjectAccessReview) 
        + DeepCopy() *LocalSubjectAccessReview
        + DeepCopyObject() runtime.Object

    }
    class NonResourceAttributes << (S,Aquamarine) >> {
        + Path string
        + Verb string

        + DeepCopyInto(out *NonResourceAttributes) 
        + DeepCopy() *NonResourceAttributes

    }
    class NonResourceRule << (S,Aquamarine) >> {
        + Verbs []string
        + NonResourceURLs []string

        + DeepCopyInto(out *NonResourceRule) 
        + DeepCopy() *NonResourceRule

    }
    class ResourceAttributes << (S,Aquamarine) >> {
        + Namespace string
        + Verb string
        + Group string
        + Version string
        + Resource string
        + Subresource string
        + Name string

        + DeepCopyInto(out *ResourceAttributes) 
        + DeepCopy() *ResourceAttributes

    }
    class ResourceRule << (S,Aquamarine) >> {
        + Verbs []string
        + APIGroups []string
        + Resources []string
        + ResourceNames []string

        + DeepCopyInto(out *ResourceRule) 
        + DeepCopy() *ResourceRule

    }
    class SelfSubjectAccessReview << (S,Aquamarine) >> {
        + Spec SelfSubjectAccessReviewSpec
        + Status SubjectAccessReviewStatus

        + DeepCopyInto(out *SelfSubjectAccessReview) 
        + DeepCopy() *SelfSubjectAccessReview
        + DeepCopyObject() runtime.Object

    }
    class SelfSubjectAccessReviewSpec << (S,Aquamarine) >> {
        + ResourceAttributes *ResourceAttributes
        + NonResourceAttributes *NonResourceAttributes

        + DeepCopyInto(out *SelfSubjectAccessReviewSpec) 
        + DeepCopy() *SelfSubjectAccessReviewSpec

    }
    class SelfSubjectRulesReview << (S,Aquamarine) >> {
        + Spec SelfSubjectRulesReviewSpec
        + Status SubjectRulesReviewStatus

        + DeepCopyInto(out *SelfSubjectRulesReview) 
        + DeepCopy() *SelfSubjectRulesReview
        + DeepCopyObject() runtime.Object

    }
    class SelfSubjectRulesReviewSpec << (S,Aquamarine) >> {
        + Namespace string

        + DeepCopyInto(out *SelfSubjectRulesReviewSpec) 
        + DeepCopy() *SelfSubjectRulesReviewSpec

    }
    class SubjectAccessReview << (S,Aquamarine) >> {
        + Spec SubjectAccessReviewSpec
        + Status SubjectAccessReviewStatus

        + DeepCopyInto(out *SubjectAccessReview) 
        + DeepCopy() *SubjectAccessReview
        + DeepCopyObject() runtime.Object

    }
    class SubjectAccessReviewSpec << (S,Aquamarine) >> {
        + ResourceAttributes *ResourceAttributes
        + NonResourceAttributes *NonResourceAttributes
        + User string
        + Groups []string
        + Extra <font color=blue>map</font>[string]ExtraValue
        + UID string

        + DeepCopyInto(out *SubjectAccessReviewSpec) 
        + DeepCopy() *SubjectAccessReviewSpec

    }
    class SubjectAccessReviewStatus << (S,Aquamarine) >> {
        + Allowed bool
        + Denied bool
        + Reason string
        + EvaluationError string

        + DeepCopyInto(out *SubjectAccessReviewStatus) 
        + DeepCopy() *SubjectAccessReviewStatus

    }
    class SubjectRulesReviewStatus << (S,Aquamarine) >> {
        + ResourceRules []ResourceRule
        + NonResourceRules []NonResourceRule
        + Incomplete bool
        + EvaluationError string

        + DeepCopyInto(out *SubjectRulesReviewStatus) 
        + DeepCopy() *SubjectRulesReviewStatus

    }
    class authorization.ExtraValue << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "authorization.LocalSubjectAccessReview"
"v1.TypeMeta" *-- "authorization.LocalSubjectAccessReview"
"v1.ObjectMeta" *-- "authorization.SelfSubjectAccessReview"
"v1.TypeMeta" *-- "authorization.SelfSubjectAccessReview"
"v1.ObjectMeta" *-- "authorization.SelfSubjectRulesReview"
"v1.TypeMeta" *-- "authorization.SelfSubjectRulesReview"
"v1.ObjectMeta" *-- "authorization.SubjectAccessReview"
"v1.TypeMeta" *-- "authorization.SubjectAccessReview"


namespace autoscaling {
    class ContainerResourceMetricSource << (S,Aquamarine) >> {
        + Name core.ResourceName
        + Container string
        + Target MetricTarget

        + DeepCopyInto(out *ContainerResourceMetricSource) 
        + DeepCopy() *ContainerResourceMetricSource

    }
    class ContainerResourceMetricStatus << (S,Aquamarine) >> {
        + Name core.ResourceName
        + Container string
        + Current MetricValueStatus

        + DeepCopyInto(out *ContainerResourceMetricStatus) 
        + DeepCopy() *ContainerResourceMetricStatus

    }
    class CrossVersionObjectReference << (S,Aquamarine) >> {
        + Kind string
        + Name string
        + APIVersion string

        + DeepCopyInto(out *CrossVersionObjectReference) 
        + DeepCopy() *CrossVersionObjectReference

    }
    class ExternalMetricSource << (S,Aquamarine) >> {
        + Metric MetricIdentifier
        + Target MetricTarget

        + DeepCopyInto(out *ExternalMetricSource) 
        + DeepCopy() *ExternalMetricSource

    }
    class ExternalMetricStatus << (S,Aquamarine) >> {
        + Metric MetricIdentifier
        + Current MetricValueStatus

        + DeepCopyInto(out *ExternalMetricStatus) 
        + DeepCopy() *ExternalMetricStatus

    }
    class HPAScalingPolicy << (S,Aquamarine) >> {
        + Type HPAScalingPolicyType
        + Value int32
        + PeriodSeconds int32

        + DeepCopyInto(out *HPAScalingPolicy) 
        + DeepCopy() *HPAScalingPolicy

    }
    class HPAScalingRules << (S,Aquamarine) >> {
        + StabilizationWindowSeconds *int32
        + SelectPolicy *ScalingPolicySelect
        + Policies []HPAScalingPolicy

        + DeepCopyInto(out *HPAScalingRules) 
        + DeepCopy() *HPAScalingRules

    }
    class HorizontalPodAutoscaler << (S,Aquamarine) >> {
        + Spec HorizontalPodAutoscalerSpec
        + Status HorizontalPodAutoscalerStatus

        + DeepCopyInto(out *HorizontalPodAutoscaler) 
        + DeepCopy() *HorizontalPodAutoscaler
        + DeepCopyObject() runtime.Object

    }
    class HorizontalPodAutoscalerBehavior << (S,Aquamarine) >> {
        + ScaleUp *HPAScalingRules
        + ScaleDown *HPAScalingRules

        + DeepCopyInto(out *HorizontalPodAutoscalerBehavior) 
        + DeepCopy() *HorizontalPodAutoscalerBehavior

    }
    class HorizontalPodAutoscalerCondition << (S,Aquamarine) >> {
        + Type HorizontalPodAutoscalerConditionType
        + Status ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *HorizontalPodAutoscalerCondition) 
        + DeepCopy() *HorizontalPodAutoscalerCondition

    }
    class HorizontalPodAutoscalerList << (S,Aquamarine) >> {
        + Items []HorizontalPodAutoscaler

        + DeepCopyInto(out *HorizontalPodAutoscalerList) 
        + DeepCopy() *HorizontalPodAutoscalerList
        + DeepCopyObject() runtime.Object

    }
    class HorizontalPodAutoscalerSpec << (S,Aquamarine) >> {
        + ScaleTargetRef CrossVersionObjectReference
        + MinReplicas *int32
        + MaxReplicas int32
        + Metrics []MetricSpec
        + Behavior *HorizontalPodAutoscalerBehavior

        + DeepCopyInto(out *HorizontalPodAutoscalerSpec) 
        + DeepCopy() *HorizontalPodAutoscalerSpec

    }
    class HorizontalPodAutoscalerStatus << (S,Aquamarine) >> {
        + ObservedGeneration *int64
        + LastScaleTime *v1.Time
        + CurrentReplicas int32
        + DesiredReplicas int32
        + CurrentMetrics []MetricStatus
        + Conditions []HorizontalPodAutoscalerCondition

        + DeepCopyInto(out *HorizontalPodAutoscalerStatus) 
        + DeepCopy() *HorizontalPodAutoscalerStatus

    }
    class MetricIdentifier << (S,Aquamarine) >> {
        + Name string
        + Selector *v1.LabelSelector

        + DeepCopyInto(out *MetricIdentifier) 
        + DeepCopy() *MetricIdentifier

    }
    class MetricSpec << (S,Aquamarine) >> {
        + Type MetricSourceType
        + Object *ObjectMetricSource
        + Pods *PodsMetricSource
        + Resource *ResourceMetricSource
        + ContainerResource *ContainerResourceMetricSource
        + External *ExternalMetricSource

        + DeepCopyInto(out *MetricSpec) 
        + DeepCopy() *MetricSpec

    }
    class MetricStatus << (S,Aquamarine) >> {
        + Type MetricSourceType
        + Object *ObjectMetricStatus
        + Pods *PodsMetricStatus
        + Resource *ResourceMetricStatus
        + ContainerResource *ContainerResourceMetricStatus
        + External *ExternalMetricStatus

        + DeepCopyInto(out *MetricStatus) 
        + DeepCopy() *MetricStatus

    }
    class MetricTarget << (S,Aquamarine) >> {
        + Type MetricTargetType
        + Value *resource.Quantity
        + AverageValue *resource.Quantity
        + AverageUtilization *int32

        + DeepCopyInto(out *MetricTarget) 
        + DeepCopy() *MetricTarget

    }
    class MetricValueStatus << (S,Aquamarine) >> {
        + Value *resource.Quantity
        + AverageValue *resource.Quantity
        + AverageUtilization *int32

        + DeepCopyInto(out *MetricValueStatus) 
        + DeepCopy() *MetricValueStatus

    }
    class ObjectMetricSource << (S,Aquamarine) >> {
        + DescribedObject CrossVersionObjectReference
        + Target MetricTarget
        + Metric MetricIdentifier

        + DeepCopyInto(out *ObjectMetricSource) 
        + DeepCopy() *ObjectMetricSource

    }
    class ObjectMetricStatus << (S,Aquamarine) >> {
        + Metric MetricIdentifier
        + Current MetricValueStatus
        + DescribedObject CrossVersionObjectReference

        + DeepCopyInto(out *ObjectMetricStatus) 
        + DeepCopy() *ObjectMetricStatus

    }
    class PodsMetricSource << (S,Aquamarine) >> {
        + Metric MetricIdentifier
        + Target MetricTarget

        + DeepCopyInto(out *PodsMetricSource) 
        + DeepCopy() *PodsMetricSource

    }
    class PodsMetricStatus << (S,Aquamarine) >> {
        + Metric MetricIdentifier
        + Current MetricValueStatus

        + DeepCopyInto(out *PodsMetricStatus) 
        + DeepCopy() *PodsMetricStatus

    }
    class ResourceMetricSource << (S,Aquamarine) >> {
        + Name core.ResourceName
        + Target MetricTarget

        + DeepCopyInto(out *ResourceMetricSource) 
        + DeepCopy() *ResourceMetricSource

    }
    class ResourceMetricStatus << (S,Aquamarine) >> {
        + Name core.ResourceName
        + Current MetricValueStatus

        + DeepCopyInto(out *ResourceMetricStatus) 
        + DeepCopy() *ResourceMetricStatus

    }
    class Scale << (S,Aquamarine) >> {
        + Spec ScaleSpec
        + Status ScaleStatus

        + DeepCopyInto(out *Scale) 
        + DeepCopy() *Scale
        + DeepCopyObject() runtime.Object

    }
    class ScaleSpec << (S,Aquamarine) >> {
        + Replicas int32

        + DeepCopyInto(out *ScaleSpec) 
        + DeepCopy() *ScaleSpec

    }
    class ScaleStatus << (S,Aquamarine) >> {
        + Replicas int32
        + Selector string

        + DeepCopyInto(out *ScaleStatus) 
        + DeepCopy() *ScaleStatus

    }
    class autoscaling.ConditionStatus << (T, #FF7700) >>  {
    }
    class autoscaling.HPAScalingPolicyType << (T, #FF7700) >>  {
    }
    class autoscaling.HorizontalPodAutoscalerConditionType << (T, #FF7700) >>  {
    }
    class autoscaling.MetricSourceType << (T, #FF7700) >>  {
    }
    class autoscaling.MetricTargetType << (T, #FF7700) >>  {
    }
    class autoscaling.ScalingPolicySelect << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "autoscaling.HorizontalPodAutoscaler"
"v1.TypeMeta" *-- "autoscaling.HorizontalPodAutoscaler"
"v1.ListMeta" *-- "autoscaling.HorizontalPodAutoscalerList"
"v1.TypeMeta" *-- "autoscaling.HorizontalPodAutoscalerList"
"v1.ObjectMeta" *-- "autoscaling.Scale"
"v1.TypeMeta" *-- "autoscaling.Scale"


namespace batch {
    class CronJob << (S,Aquamarine) >> {
        + Spec CronJobSpec
        + Status CronJobStatus

        + DeepCopyInto(out *CronJob) 
        + DeepCopy() *CronJob
        + DeepCopyObject() runtime.Object

    }
    class CronJobList << (S,Aquamarine) >> {
        + Items []CronJob

        + DeepCopyInto(out *CronJobList) 
        + DeepCopy() *CronJobList
        + DeepCopyObject() runtime.Object

    }
    class CronJobSpec << (S,Aquamarine) >> {
        + Schedule string
        + TimeZone *string
        + StartingDeadlineSeconds *int64
        + ConcurrencyPolicy ConcurrencyPolicy
        + Suspend *bool
        + JobTemplate JobTemplateSpec
        + SuccessfulJobsHistoryLimit *int32
        + FailedJobsHistoryLimit *int32

        + DeepCopyInto(out *CronJobSpec) 
        + DeepCopy() *CronJobSpec

    }
    class CronJobStatus << (S,Aquamarine) >> {
        + Active []core.ObjectReference
        + LastScheduleTime *v1.Time
        + LastSuccessfulTime *v1.Time

        + DeepCopyInto(out *CronJobStatus) 
        + DeepCopy() *CronJobStatus

    }
    class Job << (S,Aquamarine) >> {
        + Spec JobSpec
        + Status JobStatus

        + DeepCopyInto(out *Job) 
        + DeepCopy() *Job
        + DeepCopyObject() runtime.Object

    }
    class JobCondition << (S,Aquamarine) >> {
        + Type JobConditionType
        + Status core.ConditionStatus
        + LastProbeTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *JobCondition) 
        + DeepCopy() *JobCondition

    }
    class JobList << (S,Aquamarine) >> {
        + Items []Job

        + DeepCopyInto(out *JobList) 
        + DeepCopy() *JobList
        + DeepCopyObject() runtime.Object

    }
    class JobSpec << (S,Aquamarine) >> {
        + Parallelism *int32
        + Completions *int32
        + PodFailurePolicy *PodFailurePolicy
        + ActiveDeadlineSeconds *int64
        + BackoffLimit *int32
        + Selector *v1.LabelSelector
        + ManualSelector *bool
        + Template core.PodTemplateSpec
        + TTLSecondsAfterFinished *int32
        + CompletionMode *CompletionMode
        + Suspend *bool

        + DeepCopyInto(out *JobSpec) 
        + DeepCopy() *JobSpec

    }
    class JobStatus << (S,Aquamarine) >> {
        + Conditions []JobCondition
        + StartTime *v1.Time
        + CompletionTime *v1.Time
        + Active int32
        + Ready *int32
        + Succeeded int32
        + Failed int32
        + CompletedIndexes string
        + UncountedTerminatedPods *UncountedTerminatedPods

        + DeepCopyInto(out *JobStatus) 
        + DeepCopy() *JobStatus

    }
    class JobTemplate << (S,Aquamarine) >> {
        + Template JobTemplateSpec

        + DeepCopyInto(out *JobTemplate) 
        + DeepCopy() *JobTemplate
        + DeepCopyObject() runtime.Object

    }
    class JobTemplateSpec << (S,Aquamarine) >> {
        + Spec JobSpec

        + DeepCopyInto(out *JobTemplateSpec) 
        + DeepCopy() *JobTemplateSpec

    }
    class PodFailurePolicy << (S,Aquamarine) >> {
        + Rules []PodFailurePolicyRule

        + DeepCopyInto(out *PodFailurePolicy) 
        + DeepCopy() *PodFailurePolicy

    }
    class PodFailurePolicyOnExitCodesRequirement << (S,Aquamarine) >> {
        + ContainerName *string
        + Operator PodFailurePolicyOnExitCodesOperator
        + Values []int32

        + DeepCopyInto(out *PodFailurePolicyOnExitCodesRequirement) 
        + DeepCopy() *PodFailurePolicyOnExitCodesRequirement

    }
    class PodFailurePolicyOnPodConditionsPattern << (S,Aquamarine) >> {
        + Type core.PodConditionType
        + Status core.ConditionStatus

        + DeepCopyInto(out *PodFailurePolicyOnPodConditionsPattern) 
        + DeepCopy() *PodFailurePolicyOnPodConditionsPattern

    }
    class PodFailurePolicyRule << (S,Aquamarine) >> {
        + Action PodFailurePolicyAction
        + OnExitCodes *PodFailurePolicyOnExitCodesRequirement
        + OnPodConditions []PodFailurePolicyOnPodConditionsPattern

        + DeepCopyInto(out *PodFailurePolicyRule) 
        + DeepCopy() *PodFailurePolicyRule

    }
    class UncountedTerminatedPods << (S,Aquamarine) >> {
        + Succeeded []types.UID
        + Failed []types.UID

        + DeepCopyInto(out *UncountedTerminatedPods) 
        + DeepCopy() *UncountedTerminatedPods

    }
    class batch.CompletionMode << (T, #FF7700) >>  {
    }
    class batch.ConcurrencyPolicy << (T, #FF7700) >>  {
    }
    class batch.JobConditionType << (T, #FF7700) >>  {
    }
    class batch.PodFailurePolicyAction << (T, #FF7700) >>  {
    }
    class batch.PodFailurePolicyOnExitCodesOperator << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "batch.CronJob"
"v1.TypeMeta" *-- "batch.CronJob"
"v1.ListMeta" *-- "batch.CronJobList"
"v1.TypeMeta" *-- "batch.CronJobList"
"v1.ObjectMeta" *-- "batch.Job"
"v1.TypeMeta" *-- "batch.Job"
"v1.ListMeta" *-- "batch.JobList"
"v1.TypeMeta" *-- "batch.JobList"
"v1.ObjectMeta" *-- "batch.JobTemplate"
"v1.TypeMeta" *-- "batch.JobTemplate"
"v1.ObjectMeta" *-- "batch.JobTemplateSpec"


namespace certificates {
    class CertificateSigningRequest << (S,Aquamarine) >> {
        + Spec CertificateSigningRequestSpec
        + Status CertificateSigningRequestStatus

        + DeepCopyInto(out *CertificateSigningRequest) 
        + DeepCopy() *CertificateSigningRequest
        + DeepCopyObject() runtime.Object

    }
    class CertificateSigningRequestCondition << (S,Aquamarine) >> {
        + Type RequestConditionType
        + Status core.ConditionStatus
        + Reason string
        + Message string
        + LastUpdateTime v1.Time
        + LastTransitionTime v1.Time

        + DeepCopyInto(out *CertificateSigningRequestCondition) 
        + DeepCopy() *CertificateSigningRequestCondition

    }
    class CertificateSigningRequestList << (S,Aquamarine) >> {
        + Items []CertificateSigningRequest

        + DeepCopyInto(out *CertificateSigningRequestList) 
        + DeepCopy() *CertificateSigningRequestList
        + DeepCopyObject() runtime.Object

    }
    class CertificateSigningRequestSpec << (S,Aquamarine) >> {
        + Request []byte
        + SignerName string
        + ExpirationSeconds *int32
        + Usages []KeyUsage
        + Username string
        + UID string
        + Groups []string
        + Extra <font color=blue>map</font>[string]ExtraValue

        + DeepCopyInto(out *CertificateSigningRequestSpec) 
        + DeepCopy() *CertificateSigningRequestSpec

    }
    class CertificateSigningRequestStatus << (S,Aquamarine) >> {
        + Conditions []CertificateSigningRequestCondition
        + Certificate []byte

        + DeepCopyInto(out *CertificateSigningRequestStatus) 
        + DeepCopy() *CertificateSigningRequestStatus

    }
    class ExtraValue << (S,Aquamarine) >> {
        + DeepCopyInto(out *ExtraValue) 
        + DeepCopy() ExtraValue

    }
    class certificates.ExtraValue << (T, #FF7700) >>  {
    }
    class certificates.KeyUsage << (T, #FF7700) >>  {
    }
    class certificates.RequestConditionType << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "certificates.CertificateSigningRequest"
"v1.TypeMeta" *-- "certificates.CertificateSigningRequest"
"v1.ListMeta" *-- "certificates.CertificateSigningRequestList"
"v1.TypeMeta" *-- "certificates.CertificateSigningRequestList"


namespace coordination {
    class Lease << (S,Aquamarine) >> {
        + Spec LeaseSpec

        + DeepCopyInto(out *Lease) 
        + DeepCopy() *Lease
        + DeepCopyObject() runtime.Object

    }
    class LeaseList << (S,Aquamarine) >> {
        + Items []Lease

        + DeepCopyInto(out *LeaseList) 
        + DeepCopy() *LeaseList
        + DeepCopyObject() runtime.Object

    }
    class LeaseSpec << (S,Aquamarine) >> {
        + HolderIdentity *string
        + LeaseDurationSeconds *int32
        + AcquireTime *v1.MicroTime
        + RenewTime *v1.MicroTime
        + LeaseTransitions *int32

        + DeepCopyInto(out *LeaseSpec) 
        + DeepCopy() *LeaseSpec

    }
}
"v1.ObjectMeta" *-- "coordination.Lease"
"v1.TypeMeta" *-- "coordination.Lease"
"v1.ListMeta" *-- "coordination.LeaseList"
"v1.TypeMeta" *-- "coordination.LeaseList"


namespace core {
    class AWSElasticBlockStoreVolumeSource << (S,Aquamarine) >> {
        + VolumeID string
        + FSType string
        + Partition int32
        + ReadOnly bool

        + DeepCopyInto(out *AWSElasticBlockStoreVolumeSource) 
        + DeepCopy() *AWSElasticBlockStoreVolumeSource

    }
    class Affinity << (S,Aquamarine) >> {
        + NodeAffinity *NodeAffinity
        + PodAffinity *PodAffinity
        + PodAntiAffinity *PodAntiAffinity

        + DeepCopyInto(out *Affinity) 
        + DeepCopy() *Affinity

    }
    class AttachedVolume << (S,Aquamarine) >> {
        + Name UniqueVolumeName
        + DevicePath string

        + DeepCopyInto(out *AttachedVolume) 
        + DeepCopy() *AttachedVolume

    }
    class AvoidPods << (S,Aquamarine) >> {
        + PreferAvoidPods []PreferAvoidPodsEntry

        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON( []byte) error
        + DeepCopyInto(out *AvoidPods) 
        + DeepCopy() *AvoidPods

    }
    class AzureDiskVolumeSource << (S,Aquamarine) >> {
        + DiskName string
        + DataDiskURI string
        + CachingMode *AzureDataDiskCachingMode
        + FSType *string
        + ReadOnly *bool
        + Kind *AzureDataDiskKind

        + DeepCopyInto(out *AzureDiskVolumeSource) 
        + DeepCopy() *AzureDiskVolumeSource

    }
    class AzureFilePersistentVolumeSource << (S,Aquamarine) >> {
        + SecretName string
        + ShareName string
        + ReadOnly bool
        + SecretNamespace *string

        + DeepCopyInto(out *AzureFilePersistentVolumeSource) 
        + DeepCopy() *AzureFilePersistentVolumeSource

    }
    class AzureFileVolumeSource << (S,Aquamarine) >> {
        + SecretName string
        + ShareName string
        + ReadOnly bool

        + DeepCopyInto(out *AzureFileVolumeSource) 
        + DeepCopy() *AzureFileVolumeSource

    }
    class Binding << (S,Aquamarine) >> {
        + Target ObjectReference

        + DeepCopyInto(out *Binding) 
        + DeepCopy() *Binding
        + DeepCopyObject() runtime.Object

    }
    class CSIPersistentVolumeSource << (S,Aquamarine) >> {
        + Driver string
        + VolumeHandle string
        + ReadOnly bool
        + FSType string
        + VolumeAttributes <font color=blue>map</font>[string]string
        + ControllerPublishSecretRef *SecretReference
        + NodeStageSecretRef *SecretReference
        + NodePublishSecretRef *SecretReference
        + ControllerExpandSecretRef *SecretReference
        + NodeExpandSecretRef *SecretReference

        + DeepCopyInto(out *CSIPersistentVolumeSource) 
        + DeepCopy() *CSIPersistentVolumeSource

    }
    class CSIVolumeSource << (S,Aquamarine) >> {
        + Driver string
        + ReadOnly *bool
        + FSType *string
        + VolumeAttributes <font color=blue>map</font>[string]string
        + NodePublishSecretRef *LocalObjectReference

        + DeepCopyInto(out *CSIVolumeSource) 
        + DeepCopy() *CSIVolumeSource

    }
    class Capabilities << (S,Aquamarine) >> {
        + Add []Capability
        + Drop []Capability

        + DeepCopyInto(out *Capabilities) 
        + DeepCopy() *Capabilities

    }
    class CephFSPersistentVolumeSource << (S,Aquamarine) >> {
        + Monitors []string
        + Path string
        + User string
        + SecretFile string
        + SecretRef *SecretReference
        + ReadOnly bool

        + DeepCopyInto(out *CephFSPersistentVolumeSource) 
        + DeepCopy() *CephFSPersistentVolumeSource

    }
    class CephFSVolumeSource << (S,Aquamarine) >> {
        + Monitors []string
        + Path string
        + User string
        + SecretFile string
        + SecretRef *LocalObjectReference
        + ReadOnly bool

        + DeepCopyInto(out *CephFSVolumeSource) 
        + DeepCopy() *CephFSVolumeSource

    }
    class CinderPersistentVolumeSource << (S,Aquamarine) >> {
        + VolumeID string
        + FSType string
        + ReadOnly bool
        + SecretRef *SecretReference

        + DeepCopyInto(out *CinderPersistentVolumeSource) 
        + DeepCopy() *CinderPersistentVolumeSource

    }
    class CinderVolumeSource << (S,Aquamarine) >> {
        + VolumeID string
        + FSType string
        + ReadOnly bool
        + SecretRef *LocalObjectReference

        + DeepCopyInto(out *CinderVolumeSource) 
        + DeepCopy() *CinderVolumeSource

    }
    class ClaimSource << (S,Aquamarine) >> {
        + ResourceClaimName *string
        + ResourceClaimTemplateName *string

        + DeepCopyInto(out *ClaimSource) 
        + DeepCopy() *ClaimSource

    }
    class ClientIPConfig << (S,Aquamarine) >> {
        + TimeoutSeconds *int32

        + DeepCopyInto(out *ClientIPConfig) 
        + DeepCopy() *ClientIPConfig

    }
    class ComponentCondition << (S,Aquamarine) >> {
        + Type ComponentConditionType
        + Status ConditionStatus
        + Message string
        + Error string

        + DeepCopyInto(out *ComponentCondition) 
        + DeepCopy() *ComponentCondition

    }
    class ComponentStatus << (S,Aquamarine) >> {
        + Conditions []ComponentCondition

        + DeepCopyInto(out *ComponentStatus) 
        + DeepCopy() *ComponentStatus
        + DeepCopyObject() runtime.Object

    }
    class ComponentStatusList << (S,Aquamarine) >> {
        + Items []ComponentStatus

        + DeepCopyInto(out *ComponentStatusList) 
        + DeepCopy() *ComponentStatusList
        + DeepCopyObject() runtime.Object

    }
    class ConfigMap << (S,Aquamarine) >> {
        + Immutable *bool
        + Data <font color=blue>map</font>[string]string
        + BinaryData <font color=blue>map</font>[string][]byte

        + DeepCopyInto(out *ConfigMap) 
        + DeepCopy() *ConfigMap
        + DeepCopyObject() runtime.Object

    }
    class ConfigMapEnvSource << (S,Aquamarine) >> {
        + Optional *bool

        + DeepCopyInto(out *ConfigMapEnvSource) 
        + DeepCopy() *ConfigMapEnvSource

    }
    class ConfigMapKeySelector << (S,Aquamarine) >> {
        + Key string
        + Optional *bool

        + DeepCopyInto(out *ConfigMapKeySelector) 
        + DeepCopy() *ConfigMapKeySelector

    }
    class ConfigMapList << (S,Aquamarine) >> {
        + Items []ConfigMap

        + DeepCopyInto(out *ConfigMapList) 
        + DeepCopy() *ConfigMapList
        + DeepCopyObject() runtime.Object

    }
    class ConfigMapNodeConfigSource << (S,Aquamarine) >> {
        + Namespace string
        + Name string
        + UID types.UID
        + ResourceVersion string
        + KubeletConfigKey string

        + DeepCopyInto(out *ConfigMapNodeConfigSource) 
        + DeepCopy() *ConfigMapNodeConfigSource

    }
    class ConfigMapProjection << (S,Aquamarine) >> {
        + Items []KeyToPath
        + Optional *bool

        + DeepCopyInto(out *ConfigMapProjection) 
        + DeepCopy() *ConfigMapProjection

    }
    class ConfigMapVolumeSource << (S,Aquamarine) >> {
        + Items []KeyToPath
        + DefaultMode *int32
        + Optional *bool

        + DeepCopyInto(out *ConfigMapVolumeSource) 
        + DeepCopy() *ConfigMapVolumeSource

    }
    class Container << (S,Aquamarine) >> {
        + Name string
        + Image string
        + Command []string
        + Args []string
        + WorkingDir string
        + Ports []ContainerPort
        + EnvFrom []EnvFromSource
        + Env []EnvVar
        + Resources ResourceRequirements
        + ResizePolicy []ContainerResizePolicy
        + VolumeMounts []VolumeMount
        + VolumeDevices []VolumeDevice
        + LivenessProbe *Probe
        + ReadinessProbe *Probe
        + StartupProbe *Probe
        + Lifecycle *Lifecycle
        + TerminationMessagePath string
        + TerminationMessagePolicy TerminationMessagePolicy
        + ImagePullPolicy PullPolicy
        + SecurityContext *SecurityContext
        + Stdin bool
        + StdinOnce bool
        + TTY bool

        + DeepCopyInto(out *Container) 
        + DeepCopy() *Container

    }
    class ContainerImage << (S,Aquamarine) >> {
        + Names []string
        + SizeBytes int64

        + DeepCopyInto(out *ContainerImage) 
        + DeepCopy() *ContainerImage

    }
    class ContainerPort << (S,Aquamarine) >> {
        + Name string
        + HostPort int32
        + ContainerPort int32
        + Protocol Protocol
        + HostIP string

        + DeepCopyInto(out *ContainerPort) 
        + DeepCopy() *ContainerPort

    }
    class ContainerResizePolicy << (S,Aquamarine) >> {
        + ResourceName ResourceName
        + Policy ResourceResizePolicy

        + DeepCopyInto(out *ContainerResizePolicy) 
        + DeepCopy() *ContainerResizePolicy

    }
    class ContainerState << (S,Aquamarine) >> {
        + Waiting *ContainerStateWaiting
        + Running *ContainerStateRunning
        + Terminated *ContainerStateTerminated

        + DeepCopyInto(out *ContainerState) 
        + DeepCopy() *ContainerState

    }
    class ContainerStateRunning << (S,Aquamarine) >> {
        + StartedAt v1.Time

        + DeepCopyInto(out *ContainerStateRunning) 
        + DeepCopy() *ContainerStateRunning

    }
    class ContainerStateTerminated << (S,Aquamarine) >> {
        + ExitCode int32
        + Signal int32
        + Reason string
        + Message string
        + StartedAt v1.Time
        + FinishedAt v1.Time
        + ContainerID string

        + DeepCopyInto(out *ContainerStateTerminated) 
        + DeepCopy() *ContainerStateTerminated

    }
    class ContainerStateWaiting << (S,Aquamarine) >> {
        + Reason string
        + Message string

        + DeepCopyInto(out *ContainerStateWaiting) 
        + DeepCopy() *ContainerStateWaiting

    }
    class ContainerStatus << (S,Aquamarine) >> {
        + Name string
        + State ContainerState
        + LastTerminationState ContainerState
        + Ready bool
        + RestartCount int32
        + Image string
        + ImageID string
        + ContainerID string
        + Started *bool
        + ResourcesAllocated ResourceList
        + Resources *ResourceRequirements

        + DeepCopyInto(out *ContainerStatus) 
        + DeepCopy() *ContainerStatus

    }
    class DaemonEndpoint << (S,Aquamarine) >> {
        + Port int32

        + DeepCopyInto(out *DaemonEndpoint) 
        + DeepCopy() *DaemonEndpoint

    }
    class DownwardAPIProjection << (S,Aquamarine) >> {
        + Items []DownwardAPIVolumeFile

        + DeepCopyInto(out *DownwardAPIProjection) 
        + DeepCopy() *DownwardAPIProjection

    }
    class DownwardAPIVolumeFile << (S,Aquamarine) >> {
        + Path string
        + FieldRef *ObjectFieldSelector
        + ResourceFieldRef *ResourceFieldSelector
        + Mode *int32

        + DeepCopyInto(out *DownwardAPIVolumeFile) 
        + DeepCopy() *DownwardAPIVolumeFile

    }
    class DownwardAPIVolumeSource << (S,Aquamarine) >> {
        + Items []DownwardAPIVolumeFile
        + DefaultMode *int32

        + DeepCopyInto(out *DownwardAPIVolumeSource) 
        + DeepCopy() *DownwardAPIVolumeSource

    }
    class EmptyDirVolumeSource << (S,Aquamarine) >> {
        + Medium StorageMedium
        + SizeLimit *resource.Quantity

        + DeepCopyInto(out *EmptyDirVolumeSource) 
        + DeepCopy() *EmptyDirVolumeSource

    }
    class EndpointAddress << (S,Aquamarine) >> {
        + IP string
        + Hostname string
        + NodeName *string
        + TargetRef *ObjectReference

        + DeepCopyInto(out *EndpointAddress) 
        + DeepCopy() *EndpointAddress

    }
    class EndpointPort << (S,Aquamarine) >> {
        + Name string
        + Port int32
        + Protocol Protocol
        + AppProtocol *string

        + DeepCopyInto(out *EndpointPort) 
        + DeepCopy() *EndpointPort

    }
    class EndpointSubset << (S,Aquamarine) >> {
        + Addresses []EndpointAddress
        + NotReadyAddresses []EndpointAddress
        + Ports []EndpointPort

        + DeepCopyInto(out *EndpointSubset) 
        + DeepCopy() *EndpointSubset

    }
    class Endpoints << (S,Aquamarine) >> {
        + Subsets []EndpointSubset

        + DeepCopyInto(out *Endpoints) 
        + DeepCopy() *Endpoints
        + DeepCopyObject() runtime.Object

    }
    class EndpointsList << (S,Aquamarine) >> {
        + Items []Endpoints

        + DeepCopyInto(out *EndpointsList) 
        + DeepCopy() *EndpointsList
        + DeepCopyObject() runtime.Object

    }
    class EnvFromSource << (S,Aquamarine) >> {
        + Prefix string
        + ConfigMapRef *ConfigMapEnvSource
        + SecretRef *SecretEnvSource

        + DeepCopyInto(out *EnvFromSource) 
        + DeepCopy() *EnvFromSource

    }
    class EnvVar << (S,Aquamarine) >> {
        + Name string
        + Value string
        + ValueFrom *EnvVarSource

        + DeepCopyInto(out *EnvVar) 
        + DeepCopy() *EnvVar

    }
    class EnvVarSource << (S,Aquamarine) >> {
        + FieldRef *ObjectFieldSelector
        + ResourceFieldRef *ResourceFieldSelector
        + ConfigMapKeyRef *ConfigMapKeySelector
        + SecretKeyRef *SecretKeySelector

        + DeepCopyInto(out *EnvVarSource) 
        + DeepCopy() *EnvVarSource

    }
    class EphemeralContainer << (S,Aquamarine) >> {
        + TargetContainerName string

        + DeepCopyInto(out *EphemeralContainer) 
        + DeepCopy() *EphemeralContainer

    }
    class EphemeralContainerCommon << (S,Aquamarine) >> {
        + Name string
        + Image string
        + Command []string
        + Args []string
        + WorkingDir string
        + Ports []ContainerPort
        + EnvFrom []EnvFromSource
        + Env []EnvVar
        + Resources ResourceRequirements
        + ResizePolicy []ContainerResizePolicy
        + VolumeMounts []VolumeMount
        + VolumeDevices []VolumeDevice
        + LivenessProbe *Probe
        + ReadinessProbe *Probe
        + StartupProbe *Probe
        + Lifecycle *Lifecycle
        + TerminationMessagePath string
        + TerminationMessagePolicy TerminationMessagePolicy
        + ImagePullPolicy PullPolicy
        + SecurityContext *SecurityContext
        + Stdin bool
        + StdinOnce bool
        + TTY bool

        + DeepCopyInto(out *EphemeralContainerCommon) 
        + DeepCopy() *EphemeralContainerCommon

    }
    class EphemeralVolumeSource << (S,Aquamarine) >> {
        + VolumeClaimTemplate *PersistentVolumeClaimTemplate

        + DeepCopyInto(out *EphemeralVolumeSource) 
        + DeepCopy() *EphemeralVolumeSource

    }
    class Event << (S,Aquamarine) >> {
        + InvolvedObject ObjectReference
        + Reason string
        + Message string
        + Source EventSource
        + FirstTimestamp v1.Time
        + LastTimestamp v1.Time
        + Count int32
        + Type string
        + EventTime v1.MicroTime
        + Series *EventSeries
        + Action string
        + Related *ObjectReference
        + ReportingController string
        + ReportingInstance string

        + DeepCopyInto(out *Event) 
        + DeepCopy() *Event
        + DeepCopyObject() runtime.Object

    }
    class EventList << (S,Aquamarine) >> {
        + Items []Event

        + DeepCopyInto(out *EventList) 
        + DeepCopy() *EventList
        + DeepCopyObject() runtime.Object

    }
    class EventSeries << (S,Aquamarine) >> {
        + Count int32
        + LastObservedTime v1.MicroTime

        + DeepCopyInto(out *EventSeries) 
        + DeepCopy() *EventSeries

    }
    class EventSource << (S,Aquamarine) >> {
        + Component string
        + Host string

        + DeepCopyInto(out *EventSource) 
        + DeepCopy() *EventSource

    }
    class ExecAction << (S,Aquamarine) >> {
        + Command []string

        + DeepCopyInto(out *ExecAction) 
        + DeepCopy() *ExecAction

    }
    class FCVolumeSource << (S,Aquamarine) >> {
        + TargetWWNs []string
        + Lun *int32
        + FSType string
        + ReadOnly bool
        + WWIDs []string

        + DeepCopyInto(out *FCVolumeSource) 
        + DeepCopy() *FCVolumeSource

    }
    class FlexPersistentVolumeSource << (S,Aquamarine) >> {
        + Driver string
        + FSType string
        + SecretRef *SecretReference
        + ReadOnly bool
        + Options <font color=blue>map</font>[string]string

        + DeepCopyInto(out *FlexPersistentVolumeSource) 
        + DeepCopy() *FlexPersistentVolumeSource

    }
    class FlexVolumeSource << (S,Aquamarine) >> {
        + Driver string
        + FSType string
        + SecretRef *LocalObjectReference
        + ReadOnly bool
        + Options <font color=blue>map</font>[string]string

        + DeepCopyInto(out *FlexVolumeSource) 
        + DeepCopy() *FlexVolumeSource

    }
    class FlockerVolumeSource << (S,Aquamarine) >> {
        + DatasetName string
        + DatasetUUID string

        + DeepCopyInto(out *FlockerVolumeSource) 
        + DeepCopy() *FlockerVolumeSource

    }
    class GCEPersistentDiskVolumeSource << (S,Aquamarine) >> {
        + PDName string
        + FSType string
        + Partition int32
        + ReadOnly bool

        + DeepCopyInto(out *GCEPersistentDiskVolumeSource) 
        + DeepCopy() *GCEPersistentDiskVolumeSource

    }
    class GRPCAction << (S,Aquamarine) >> {
        + Port int32
        + Service *string

        + DeepCopyInto(out *GRPCAction) 
        + DeepCopy() *GRPCAction

    }
    class GitRepoVolumeSource << (S,Aquamarine) >> {
        + Repository string
        + Revision string
        + Directory string

        + DeepCopyInto(out *GitRepoVolumeSource) 
        + DeepCopy() *GitRepoVolumeSource

    }
    class GlusterfsPersistentVolumeSource << (S,Aquamarine) >> {
        + EndpointsName string
        + Path string
        + ReadOnly bool
        + EndpointsNamespace *string

        + DeepCopyInto(out *GlusterfsPersistentVolumeSource) 
        + DeepCopy() *GlusterfsPersistentVolumeSource

    }
    class GlusterfsVolumeSource << (S,Aquamarine) >> {
        + EndpointsName string
        + Path string
        + ReadOnly bool

        + DeepCopyInto(out *GlusterfsVolumeSource) 
        + DeepCopy() *GlusterfsVolumeSource

    }
    class HTTPGetAction << (S,Aquamarine) >> {
        + Path string
        + Port intstr.IntOrString
        + Host string
        + Scheme URIScheme
        + HTTPHeaders []HTTPHeader

        + DeepCopyInto(out *HTTPGetAction) 
        + DeepCopy() *HTTPGetAction

    }
    class HTTPHeader << (S,Aquamarine) >> {
        + Name string
        + Value string

        + DeepCopyInto(out *HTTPHeader) 
        + DeepCopy() *HTTPHeader

    }
    class HostAlias << (S,Aquamarine) >> {
        + IP string
        + Hostnames []string

        + DeepCopyInto(out *HostAlias) 
        + DeepCopy() *HostAlias

    }
    class HostPathVolumeSource << (S,Aquamarine) >> {
        + Path string
        + Type *HostPathType

        + DeepCopyInto(out *HostPathVolumeSource) 
        + DeepCopy() *HostPathVolumeSource

    }
    class ISCSIPersistentVolumeSource << (S,Aquamarine) >> {
        + TargetPortal string
        + IQN string
        + Lun int32
        + ISCSIInterface string
        + FSType string
        + ReadOnly bool
        + Portals []string
        + DiscoveryCHAPAuth bool
        + SessionCHAPAuth bool
        + SecretRef *SecretReference
        + InitiatorName *string

        + DeepCopyInto(out *ISCSIPersistentVolumeSource) 
        + DeepCopy() *ISCSIPersistentVolumeSource

    }
    class ISCSIVolumeSource << (S,Aquamarine) >> {
        + TargetPortal string
        + IQN string
        + Lun int32
        + ISCSIInterface string
        + FSType string
        + ReadOnly bool
        + Portals []string
        + DiscoveryCHAPAuth bool
        + SessionCHAPAuth bool
        + SecretRef *LocalObjectReference
        + InitiatorName *string

        + DeepCopyInto(out *ISCSIVolumeSource) 
        + DeepCopy() *ISCSIVolumeSource

    }
    class KeyToPath << (S,Aquamarine) >> {
        + Key string
        + Path string
        + Mode *int32

        + DeepCopyInto(out *KeyToPath) 
        + DeepCopy() *KeyToPath

    }
    class Lifecycle << (S,Aquamarine) >> {
        + PostStart *LifecycleHandler
        + PreStop *LifecycleHandler

        + DeepCopyInto(out *Lifecycle) 
        + DeepCopy() *Lifecycle

    }
    class LifecycleHandler << (S,Aquamarine) >> {
        + Exec *ExecAction
        + HTTPGet *HTTPGetAction
        + TCPSocket *TCPSocketAction

        + DeepCopyInto(out *LifecycleHandler) 
        + DeepCopy() *LifecycleHandler

    }
    class LimitRange << (S,Aquamarine) >> {
        + Spec LimitRangeSpec

        + DeepCopyInto(out *LimitRange) 
        + DeepCopy() *LimitRange
        + DeepCopyObject() runtime.Object

    }
    class LimitRangeItem << (S,Aquamarine) >> {
        + Type LimitType
        + Max ResourceList
        + Min ResourceList
        + Default ResourceList
        + DefaultRequest ResourceList
        + MaxLimitRequestRatio ResourceList

        + DeepCopyInto(out *LimitRangeItem) 
        + DeepCopy() *LimitRangeItem

    }
    class LimitRangeList << (S,Aquamarine) >> {
        + Items []LimitRange

        + DeepCopyInto(out *LimitRangeList) 
        + DeepCopy() *LimitRangeList
        + DeepCopyObject() runtime.Object

    }
    class LimitRangeSpec << (S,Aquamarine) >> {
        + Limits []LimitRangeItem

        + DeepCopyInto(out *LimitRangeSpec) 
        + DeepCopy() *LimitRangeSpec

    }
    class List << (S,Aquamarine) >> {
        + DeepCopyInto(out *List) 
        + DeepCopy() *List
        + DeepCopyObject() runtime.Object

    }
    class LoadBalancerIngress << (S,Aquamarine) >> {
        + IP string
        + Hostname string
        + Ports []PortStatus

        + DeepCopyInto(out *LoadBalancerIngress) 
        + DeepCopy() *LoadBalancerIngress

    }
    class LoadBalancerStatus << (S,Aquamarine) >> {
        + Ingress []LoadBalancerIngress

        + DeepCopyInto(out *LoadBalancerStatus) 
        + DeepCopy() *LoadBalancerStatus

    }
    class LocalObjectReference << (S,Aquamarine) >> {
        + Name string

        + DeepCopyInto(out *LocalObjectReference) 
        + DeepCopy() *LocalObjectReference

    }
    class LocalVolumeSource << (S,Aquamarine) >> {
        + Path string
        + FSType *string

        + DeepCopyInto(out *LocalVolumeSource) 
        + DeepCopy() *LocalVolumeSource

    }
    class NFSVolumeSource << (S,Aquamarine) >> {
        + Server string
        + Path string
        + ReadOnly bool

        + DeepCopyInto(out *NFSVolumeSource) 
        + DeepCopy() *NFSVolumeSource

    }
    class Namespace << (S,Aquamarine) >> {
        + Spec NamespaceSpec
        + Status NamespaceStatus

        + DeepCopyInto(out *Namespace) 
        + DeepCopy() *Namespace
        + DeepCopyObject() runtime.Object

    }
    class NamespaceCondition << (S,Aquamarine) >> {
        + Type NamespaceConditionType
        + Status ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *NamespaceCondition) 
        + DeepCopy() *NamespaceCondition

    }
    class NamespaceList << (S,Aquamarine) >> {
        + Items []Namespace

        + DeepCopyInto(out *NamespaceList) 
        + DeepCopy() *NamespaceList
        + DeepCopyObject() runtime.Object

    }
    class NamespaceSpec << (S,Aquamarine) >> {
        + Finalizers []FinalizerName

        + DeepCopyInto(out *NamespaceSpec) 
        + DeepCopy() *NamespaceSpec

    }
    class NamespaceStatus << (S,Aquamarine) >> {
        + Phase NamespacePhase
        + Conditions []NamespaceCondition

        + DeepCopyInto(out *NamespaceStatus) 
        + DeepCopy() *NamespaceStatus

    }
    class Node << (S,Aquamarine) >> {
        + Spec NodeSpec
        + Status NodeStatus

        + DeepCopyInto(out *Node) 
        + DeepCopy() *Node
        + DeepCopyObject() runtime.Object

    }
    class NodeAddress << (S,Aquamarine) >> {
        + Type NodeAddressType
        + Address string

        + DeepCopyInto(out *NodeAddress) 
        + DeepCopy() *NodeAddress

    }
    class NodeAffinity << (S,Aquamarine) >> {
        + RequiredDuringSchedulingIgnoredDuringExecution *NodeSelector
        + PreferredDuringSchedulingIgnoredDuringExecution []PreferredSchedulingTerm

        + DeepCopyInto(out *NodeAffinity) 
        + DeepCopy() *NodeAffinity

    }
    class NodeCondition << (S,Aquamarine) >> {
        + Type NodeConditionType
        + Status ConditionStatus
        + LastHeartbeatTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *NodeCondition) 
        + DeepCopy() *NodeCondition

    }
    class NodeConfigSource << (S,Aquamarine) >> {
        + ConfigMap *ConfigMapNodeConfigSource

        + DeepCopyInto(out *NodeConfigSource) 
        + DeepCopy() *NodeConfigSource

    }
    class NodeConfigStatus << (S,Aquamarine) >> {
        + Assigned *NodeConfigSource
        + Active *NodeConfigSource
        + LastKnownGood *NodeConfigSource
        + Error string

        + DeepCopyInto(out *NodeConfigStatus) 
        + DeepCopy() *NodeConfigStatus

    }
    class NodeDaemonEndpoints << (S,Aquamarine) >> {
        + KubeletEndpoint DaemonEndpoint

        + DeepCopyInto(out *NodeDaemonEndpoints) 
        + DeepCopy() *NodeDaemonEndpoints

    }
    class NodeList << (S,Aquamarine) >> {
        + Items []Node

        + DeepCopyInto(out *NodeList) 
        + DeepCopy() *NodeList
        + DeepCopyObject() runtime.Object

    }
    class NodeProxyOptions << (S,Aquamarine) >> {
        + Path string

        + DeepCopyInto(out *NodeProxyOptions) 
        + DeepCopy() *NodeProxyOptions
        + DeepCopyObject() runtime.Object

    }
    class NodeResources << (S,Aquamarine) >> {
        + Capacity ResourceList

        + DeepCopyInto(out *NodeResources) 
        + DeepCopy() *NodeResources

    }
    class NodeSelector << (S,Aquamarine) >> {
        + NodeSelectorTerms []NodeSelectorTerm

        + DeepCopyInto(out *NodeSelector) 
        + DeepCopy() *NodeSelector

    }
    class NodeSelectorRequirement << (S,Aquamarine) >> {
        + Key string
        + Operator NodeSelectorOperator
        + Values []string

        + DeepCopyInto(out *NodeSelectorRequirement) 
        + DeepCopy() *NodeSelectorRequirement

    }
    class NodeSelectorTerm << (S,Aquamarine) >> {
        + MatchExpressions []NodeSelectorRequirement
        + MatchFields []NodeSelectorRequirement

        + DeepCopyInto(out *NodeSelectorTerm) 
        + DeepCopy() *NodeSelectorTerm

    }
    class NodeSpec << (S,Aquamarine) >> {
        + PodCIDRs []string
        + ProviderID string
        + Unschedulable bool
        + Taints []Taint
        + ConfigSource *NodeConfigSource
        + DoNotUseExternalID string

        + DeepCopyInto(out *NodeSpec) 
        + DeepCopy() *NodeSpec

    }
    class NodeStatus << (S,Aquamarine) >> {
        + Capacity ResourceList
        + Allocatable ResourceList
        + Phase NodePhase
        + Conditions []NodeCondition
        + Addresses []NodeAddress
        + DaemonEndpoints NodeDaemonEndpoints
        + NodeInfo NodeSystemInfo
        + Images []ContainerImage
        + VolumesInUse []UniqueVolumeName
        + VolumesAttached []AttachedVolume
        + Config *NodeConfigStatus

        + DeepCopyInto(out *NodeStatus) 
        + DeepCopy() *NodeStatus

    }
    class NodeSystemInfo << (S,Aquamarine) >> {
        + MachineID string
        + SystemUUID string
        + BootID string
        + KernelVersion string
        + OSImage string
        + ContainerRuntimeVersion string
        + KubeletVersion string
        + KubeProxyVersion string
        + OperatingSystem string
        + Architecture string

        + DeepCopyInto(out *NodeSystemInfo) 
        + DeepCopy() *NodeSystemInfo

    }
    class ObjectFieldSelector << (S,Aquamarine) >> {
        + APIVersion string
        + FieldPath string

        + DeepCopyInto(out *ObjectFieldSelector) 
        + DeepCopy() *ObjectFieldSelector

    }
    class ObjectReference << (S,Aquamarine) >> {
        + Kind string
        + Namespace string
        + Name string
        + UID types.UID
        + APIVersion string
        + ResourceVersion string
        + FieldPath string

        + SetGroupVersionKind(gvk schema.GroupVersionKind) 
        + GroupVersionKind() schema.GroupVersionKind
        + GetObjectKind() schema.ObjectKind
        + DeepCopyInto(out *ObjectReference) 
        + DeepCopy() *ObjectReference
        + DeepCopyObject() runtime.Object

    }
    class PersistentVolume << (S,Aquamarine) >> {
        + Spec PersistentVolumeSpec
        + Status PersistentVolumeStatus

        + DeepCopyInto(out *PersistentVolume) 
        + DeepCopy() *PersistentVolume
        + DeepCopyObject() runtime.Object

    }
    class PersistentVolumeClaim << (S,Aquamarine) >> {
        + Spec PersistentVolumeClaimSpec
        + Status PersistentVolumeClaimStatus

        + DeepCopyInto(out *PersistentVolumeClaim) 
        + DeepCopy() *PersistentVolumeClaim
        + DeepCopyObject() runtime.Object

    }
    class PersistentVolumeClaimCondition << (S,Aquamarine) >> {
        + Type PersistentVolumeClaimConditionType
        + Status ConditionStatus
        + LastProbeTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *PersistentVolumeClaimCondition) 
        + DeepCopy() *PersistentVolumeClaimCondition

    }
    class PersistentVolumeClaimList << (S,Aquamarine) >> {
        + Items []PersistentVolumeClaim

        + DeepCopyInto(out *PersistentVolumeClaimList) 
        + DeepCopy() *PersistentVolumeClaimList
        + DeepCopyObject() runtime.Object

    }
    class PersistentVolumeClaimSpec << (S,Aquamarine) >> {
        + AccessModes []PersistentVolumeAccessMode
        + Selector *v1.LabelSelector
        + Resources ResourceRequirements
        + VolumeName string
        + StorageClassName *string
        + VolumeMode *PersistentVolumeMode
        + DataSource *TypedLocalObjectReference
        + DataSourceRef *TypedObjectReference

        + DeepCopyInto(out *PersistentVolumeClaimSpec) 
        + DeepCopy() *PersistentVolumeClaimSpec

    }
    class PersistentVolumeClaimStatus << (S,Aquamarine) >> {
        + Phase PersistentVolumeClaimPhase
        + AccessModes []PersistentVolumeAccessMode
        + Capacity ResourceList
        + Conditions []PersistentVolumeClaimCondition
        + AllocatedResources ResourceList
        + ResizeStatus *PersistentVolumeClaimResizeStatus

        + DeepCopyInto(out *PersistentVolumeClaimStatus) 
        + DeepCopy() *PersistentVolumeClaimStatus

    }
    class PersistentVolumeClaimTemplate << (S,Aquamarine) >> {
        + Spec PersistentVolumeClaimSpec

        + DeepCopyInto(out *PersistentVolumeClaimTemplate) 
        + DeepCopy() *PersistentVolumeClaimTemplate

    }
    class PersistentVolumeClaimVolumeSource << (S,Aquamarine) >> {
        + ClaimName string
        + ReadOnly bool

        + DeepCopyInto(out *PersistentVolumeClaimVolumeSource) 
        + DeepCopy() *PersistentVolumeClaimVolumeSource

    }
    class PersistentVolumeList << (S,Aquamarine) >> {
        + Items []PersistentVolume

        + DeepCopyInto(out *PersistentVolumeList) 
        + DeepCopy() *PersistentVolumeList
        + DeepCopyObject() runtime.Object

    }
    class PersistentVolumeSource << (S,Aquamarine) >> {
        + GCEPersistentDisk *GCEPersistentDiskVolumeSource
        + AWSElasticBlockStore *AWSElasticBlockStoreVolumeSource
        + HostPath *HostPathVolumeSource
        + Glusterfs *GlusterfsPersistentVolumeSource
        + NFS *NFSVolumeSource
        + RBD *RBDPersistentVolumeSource
        + Quobyte *QuobyteVolumeSource
        + ISCSI *ISCSIPersistentVolumeSource
        + FlexVolume *FlexPersistentVolumeSource
        + Cinder *CinderPersistentVolumeSource
        + CephFS *CephFSPersistentVolumeSource
        + FC *FCVolumeSource
        + Flocker *FlockerVolumeSource
        + AzureFile *AzureFilePersistentVolumeSource
        + VsphereVolume *VsphereVirtualDiskVolumeSource
        + AzureDisk *AzureDiskVolumeSource
        + PhotonPersistentDisk *PhotonPersistentDiskVolumeSource
        + PortworxVolume *PortworxVolumeSource
        + ScaleIO *ScaleIOPersistentVolumeSource
        + Local *LocalVolumeSource
        + StorageOS *StorageOSPersistentVolumeSource
        + CSI *CSIPersistentVolumeSource

        + DeepCopyInto(out *PersistentVolumeSource) 
        + DeepCopy() *PersistentVolumeSource

    }
    class PersistentVolumeSpec << (S,Aquamarine) >> {
        + Capacity ResourceList
        + AccessModes []PersistentVolumeAccessMode
        + ClaimRef *ObjectReference
        + PersistentVolumeReclaimPolicy PersistentVolumeReclaimPolicy
        + StorageClassName string
        + MountOptions []string
        + VolumeMode *PersistentVolumeMode
        + NodeAffinity *VolumeNodeAffinity

        + DeepCopyInto(out *PersistentVolumeSpec) 
        + DeepCopy() *PersistentVolumeSpec

    }
    class PersistentVolumeStatus << (S,Aquamarine) >> {
        + Phase PersistentVolumePhase
        + Message string
        + Reason string

        + DeepCopyInto(out *PersistentVolumeStatus) 
        + DeepCopy() *PersistentVolumeStatus

    }
    class PhotonPersistentDiskVolumeSource << (S,Aquamarine) >> {
        + PdID string
        + FSType string

        + DeepCopyInto(out *PhotonPersistentDiskVolumeSource) 
        + DeepCopy() *PhotonPersistentDiskVolumeSource

    }
    class Pod << (S,Aquamarine) >> {
        + Spec PodSpec
        + Status PodStatus

        + DeepCopyInto(out *Pod) 
        + DeepCopy() *Pod
        + DeepCopyObject() runtime.Object

    }
    class PodAffinity << (S,Aquamarine) >> {
        + RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm
        + PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm

        + DeepCopyInto(out *PodAffinity) 
        + DeepCopy() *PodAffinity

    }
    class PodAffinityTerm << (S,Aquamarine) >> {
        + LabelSelector *v1.LabelSelector
        + Namespaces []string
        + TopologyKey string
        + NamespaceSelector *v1.LabelSelector

        + DeepCopyInto(out *PodAffinityTerm) 
        + DeepCopy() *PodAffinityTerm

    }
    class PodAntiAffinity << (S,Aquamarine) >> {
        + RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm
        + PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm

        + DeepCopyInto(out *PodAntiAffinity) 
        + DeepCopy() *PodAntiAffinity

    }
    class PodAttachOptions << (S,Aquamarine) >> {
        + Stdin bool
        + Stdout bool
        + Stderr bool
        + TTY bool
        + Container string

        + DeepCopyInto(out *PodAttachOptions) 
        + DeepCopy() *PodAttachOptions
        + DeepCopyObject() runtime.Object

    }
    class PodCondition << (S,Aquamarine) >> {
        + Type PodConditionType
        + Status ConditionStatus
        + LastProbeTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *PodCondition) 
        + DeepCopy() *PodCondition

    }
    class PodDNSConfig << (S,Aquamarine) >> {
        + Nameservers []string
        + Searches []string
        + Options []PodDNSConfigOption

        + DeepCopyInto(out *PodDNSConfig) 
        + DeepCopy() *PodDNSConfig

    }
    class PodDNSConfigOption << (S,Aquamarine) >> {
        + Name string
        + Value *string

        + DeepCopyInto(out *PodDNSConfigOption) 
        + DeepCopy() *PodDNSConfigOption

    }
    class PodExecOptions << (S,Aquamarine) >> {
        + Stdin bool
        + Stdout bool
        + Stderr bool
        + TTY bool
        + Container string
        + Command []string

        + DeepCopyInto(out *PodExecOptions) 
        + DeepCopy() *PodExecOptions
        + DeepCopyObject() runtime.Object

    }
    class PodIP << (S,Aquamarine) >> {
        + IP string

        + DeepCopyInto(out *PodIP) 
        + DeepCopy() *PodIP

    }
    class PodList << (S,Aquamarine) >> {
        + Items []Pod

        + DeepCopyInto(out *PodList) 
        + DeepCopy() *PodList
        + DeepCopyObject() runtime.Object

    }
    class PodLogOptions << (S,Aquamarine) >> {
        + Container string
        + Follow bool
        + Previous bool
        + SinceSeconds *int64
        + SinceTime *v1.Time
        + Timestamps bool
        + TailLines *int64
        + LimitBytes *int64
        + InsecureSkipTLSVerifyBackend bool

        + DeepCopyInto(out *PodLogOptions) 
        + DeepCopy() *PodLogOptions
        + DeepCopyObject() runtime.Object

    }
    class PodOS << (S,Aquamarine) >> {
        + Name OSName

        + DeepCopyInto(out *PodOS) 
        + DeepCopy() *PodOS

    }
    class PodPortForwardOptions << (S,Aquamarine) >> {
        + Ports []int32

        + DeepCopyInto(out *PodPortForwardOptions) 
        + DeepCopy() *PodPortForwardOptions
        + DeepCopyObject() runtime.Object

    }
    class PodProxyOptions << (S,Aquamarine) >> {
        + Path string

        + DeepCopyInto(out *PodProxyOptions) 
        + DeepCopy() *PodProxyOptions
        + DeepCopyObject() runtime.Object

    }
    class PodReadinessGate << (S,Aquamarine) >> {
        + ConditionType PodConditionType

        + DeepCopyInto(out *PodReadinessGate) 
        + DeepCopy() *PodReadinessGate

    }
    class PodResourceClaim << (S,Aquamarine) >> {
        + Name string
        + Source ClaimSource

        + DeepCopyInto(out *PodResourceClaim) 
        + DeepCopy() *PodResourceClaim

    }
    class PodSchedulingGate << (S,Aquamarine) >> {
        + Name string

        + DeepCopyInto(out *PodSchedulingGate) 
        + DeepCopy() *PodSchedulingGate

    }
    class PodSecurityContext << (S,Aquamarine) >> {
        + HostNetwork bool
        + HostPID bool
        + HostIPC bool
        + ShareProcessNamespace *bool
        + HostUsers *bool
        + SELinuxOptions *SELinuxOptions
        + WindowsOptions *WindowsSecurityContextOptions
        + RunAsUser *int64
        + RunAsGroup *int64
        + RunAsNonRoot *bool
        + SupplementalGroups []int64
        + FSGroup *int64
        + FSGroupChangePolicy *PodFSGroupChangePolicy
        + Sysctls []Sysctl
        + SeccompProfile *SeccompProfile

        + DeepCopyInto(out *PodSecurityContext) 
        + DeepCopy() *PodSecurityContext

    }
    class PodSignature << (S,Aquamarine) >> {
        + PodController *v1.OwnerReference

        + DeepCopyInto(out *PodSignature) 
        + DeepCopy() *PodSignature

    }
    class PodSpec << (S,Aquamarine) >> {
        + Volumes []Volume
        + InitContainers []Container
        + Containers []Container
        + EphemeralContainers []EphemeralContainer
        + RestartPolicy RestartPolicy
        + TerminationGracePeriodSeconds *int64
        + ActiveDeadlineSeconds *int64
        + DNSPolicy DNSPolicy
        + NodeSelector <font color=blue>map</font>[string]string
        + ServiceAccountName string
        + AutomountServiceAccountToken *bool
        + NodeName string
        + SecurityContext *PodSecurityContext
        + ImagePullSecrets []LocalObjectReference
        + Hostname string
        + Subdomain string
        + SetHostnameAsFQDN *bool
        + Affinity *Affinity
        + SchedulerName string
        + Tolerations []Toleration
        + HostAliases []HostAlias
        + PriorityClassName string
        + Priority *int32
        + PreemptionPolicy *PreemptionPolicy
        + DNSConfig *PodDNSConfig
        + ReadinessGates []PodReadinessGate
        + RuntimeClassName *string
        + Overhead ResourceList
        + EnableServiceLinks *bool
        + TopologySpreadConstraints []TopologySpreadConstraint
        + OS *PodOS
        + SchedulingGates []PodSchedulingGate
        + ResourceClaims []PodResourceClaim

        + DeepCopyInto(out *PodSpec) 
        + DeepCopy() *PodSpec

    }
    class PodStatus << (S,Aquamarine) >> {
        + Phase PodPhase
        + Conditions []PodCondition
        + Message string
        + Reason string
        + NominatedNodeName string
        + HostIP string
        + PodIPs []PodIP
        + StartTime *v1.Time
        + QOSClass PodQOSClass
        + InitContainerStatuses []ContainerStatus
        + ContainerStatuses []ContainerStatus
        + EphemeralContainerStatuses []ContainerStatus
        + Resize PodResizeStatus

        + DeepCopyInto(out *PodStatus) 
        + DeepCopy() *PodStatus

    }
    class PodStatusResult << (S,Aquamarine) >> {
        + Status PodStatus

        + DeepCopyInto(out *PodStatusResult) 
        + DeepCopy() *PodStatusResult
        + DeepCopyObject() runtime.Object

    }
    class PodTemplate << (S,Aquamarine) >> {
        + Template PodTemplateSpec

        + DeepCopyInto(out *PodTemplate) 
        + DeepCopy() *PodTemplate
        + DeepCopyObject() runtime.Object

    }
    class PodTemplateList << (S,Aquamarine) >> {
        + Items []PodTemplate

        + DeepCopyInto(out *PodTemplateList) 
        + DeepCopy() *PodTemplateList
        + DeepCopyObject() runtime.Object

    }
    class PodTemplateSpec << (S,Aquamarine) >> {
        + Spec PodSpec

        + DeepCopyInto(out *PodTemplateSpec) 
        + DeepCopy() *PodTemplateSpec

    }
    class PortStatus << (S,Aquamarine) >> {
        + Port int32
        + Protocol Protocol
        + Error *string

        + DeepCopyInto(out *PortStatus) 
        + DeepCopy() *PortStatus

    }
    class PortworxVolumeSource << (S,Aquamarine) >> {
        + VolumeID string
        + FSType string
        + ReadOnly bool

        + DeepCopyInto(out *PortworxVolumeSource) 
        + DeepCopy() *PortworxVolumeSource

    }
    class Preconditions << (S,Aquamarine) >> {
        + UID *types.UID

        + DeepCopyInto(out *Preconditions) 
        + DeepCopy() *Preconditions

    }
    class PreferAvoidPodsEntry << (S,Aquamarine) >> {
        + PodSignature PodSignature
        + EvictionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *PreferAvoidPodsEntry) 
        + DeepCopy() *PreferAvoidPodsEntry

    }
    class PreferredSchedulingTerm << (S,Aquamarine) >> {
        + Weight int32
        + Preference NodeSelectorTerm

        + DeepCopyInto(out *PreferredSchedulingTerm) 
        + DeepCopy() *PreferredSchedulingTerm

    }
    class Probe << (S,Aquamarine) >> {
        + InitialDelaySeconds int32
        + TimeoutSeconds int32
        + PeriodSeconds int32
        + SuccessThreshold int32
        + FailureThreshold int32
        + TerminationGracePeriodSeconds *int64

        + DeepCopyInto(out *Probe) 
        + DeepCopy() *Probe

    }
    class ProbeHandler << (S,Aquamarine) >> {
        + Exec *ExecAction
        + HTTPGet *HTTPGetAction
        + TCPSocket *TCPSocketAction
        + GRPC *GRPCAction

        + DeepCopyInto(out *ProbeHandler) 
        + DeepCopy() *ProbeHandler

    }
    class ProjectedVolumeSource << (S,Aquamarine) >> {
        + Sources []VolumeProjection
        + DefaultMode *int32

        + DeepCopyInto(out *ProjectedVolumeSource) 
        + DeepCopy() *ProjectedVolumeSource

    }
    class QuobyteVolumeSource << (S,Aquamarine) >> {
        + Registry string
        + Volume string
        + ReadOnly bool
        + User string
        + Group string
        + Tenant string

        + DeepCopyInto(out *QuobyteVolumeSource) 
        + DeepCopy() *QuobyteVolumeSource

    }
    class RBDPersistentVolumeSource << (S,Aquamarine) >> {
        + CephMonitors []string
        + RBDImage string
        + FSType string
        + RBDPool string
        + RadosUser string
        + Keyring string
        + SecretRef *SecretReference
        + ReadOnly bool

        + DeepCopyInto(out *RBDPersistentVolumeSource) 
        + DeepCopy() *RBDPersistentVolumeSource

    }
    class RBDVolumeSource << (S,Aquamarine) >> {
        + CephMonitors []string
        + RBDImage string
        + FSType string
        + RBDPool string
        + RadosUser string
        + Keyring string
        + SecretRef *LocalObjectReference
        + ReadOnly bool

        + DeepCopyInto(out *RBDVolumeSource) 
        + DeepCopy() *RBDVolumeSource

    }
    class RangeAllocation << (S,Aquamarine) >> {
        + Range string
        + Data []byte

        + DeepCopyInto(out *RangeAllocation) 
        + DeepCopy() *RangeAllocation
        + DeepCopyObject() runtime.Object

    }
    class ReplicationController << (S,Aquamarine) >> {
        + Spec ReplicationControllerSpec
        + Status ReplicationControllerStatus

        + DeepCopyInto(out *ReplicationController) 
        + DeepCopy() *ReplicationController
        + DeepCopyObject() runtime.Object

    }
    class ReplicationControllerCondition << (S,Aquamarine) >> {
        + Type ReplicationControllerConditionType
        + Status ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *ReplicationControllerCondition) 
        + DeepCopy() *ReplicationControllerCondition

    }
    class ReplicationControllerList << (S,Aquamarine) >> {
        + Items []ReplicationController

        + DeepCopyInto(out *ReplicationControllerList) 
        + DeepCopy() *ReplicationControllerList
        + DeepCopyObject() runtime.Object

    }
    class ReplicationControllerSpec << (S,Aquamarine) >> {
        + Replicas int32
        + MinReadySeconds int32
        + Selector <font color=blue>map</font>[string]string
        + Template *PodTemplateSpec

        + DeepCopyInto(out *ReplicationControllerSpec) 
        + DeepCopy() *ReplicationControllerSpec

    }
    class ReplicationControllerStatus << (S,Aquamarine) >> {
        + Replicas int32
        + FullyLabeledReplicas int32
        + ReadyReplicas int32
        + AvailableReplicas int32
        + ObservedGeneration int64
        + Conditions []ReplicationControllerCondition

        + DeepCopyInto(out *ReplicationControllerStatus) 
        + DeepCopy() *ReplicationControllerStatus

    }
    class ResourceClaim << (S,Aquamarine) >> {
        + Name string

        + DeepCopyInto(out *ResourceClaim) 
        + DeepCopy() *ResourceClaim

    }
    class ResourceFieldSelector << (S,Aquamarine) >> {
        + ContainerName string
        + Resource string
        + Divisor resource.Quantity

        + DeepCopyInto(out *ResourceFieldSelector) 
        + DeepCopy() *ResourceFieldSelector

    }
    class ResourceList << (S,Aquamarine) >> {
        + CPU() *resource.Quantity
        + Memory() *resource.Quantity
        + Storage() *resource.Quantity
        + Pods() *resource.Quantity
        + StorageEphemeral() *resource.Quantity
        + Name(name ResourceName, defaultFormat resource.Format) *resource.Quantity
        + DeepCopyInto(out *ResourceList) 
        + DeepCopy() ResourceList

    }
    class ResourceName << (S,Aquamarine) >> {
        + String() string

    }
    class ResourceQuota << (S,Aquamarine) >> {
        + Spec ResourceQuotaSpec
        + Status ResourceQuotaStatus

        + DeepCopyInto(out *ResourceQuota) 
        + DeepCopy() *ResourceQuota
        + DeepCopyObject() runtime.Object

    }
    class ResourceQuotaList << (S,Aquamarine) >> {
        + Items []ResourceQuota

        + DeepCopyInto(out *ResourceQuotaList) 
        + DeepCopy() *ResourceQuotaList
        + DeepCopyObject() runtime.Object

    }
    class ResourceQuotaSpec << (S,Aquamarine) >> {
        + Hard ResourceList
        + Scopes []ResourceQuotaScope
        + ScopeSelector *ScopeSelector

        + DeepCopyInto(out *ResourceQuotaSpec) 
        + DeepCopy() *ResourceQuotaSpec

    }
    class ResourceQuotaStatus << (S,Aquamarine) >> {
        + Hard ResourceList
        + Used ResourceList

        + DeepCopyInto(out *ResourceQuotaStatus) 
        + DeepCopy() *ResourceQuotaStatus

    }
    class ResourceRequirements << (S,Aquamarine) >> {
        + Limits ResourceList
        + Requests ResourceList
        + Claims []ResourceClaim

        + DeepCopyInto(out *ResourceRequirements) 
        + DeepCopy() *ResourceRequirements

    }
    class SELinuxOptions << (S,Aquamarine) >> {
        + User string
        + Role string
        + Type string
        + Level string

        + DeepCopyInto(out *SELinuxOptions) 
        + DeepCopy() *SELinuxOptions

    }
    class ScaleIOPersistentVolumeSource << (S,Aquamarine) >> {
        + Gateway string
        + System string
        + SecretRef *SecretReference
        + SSLEnabled bool
        + ProtectionDomain string
        + StoragePool string
        + StorageMode string
        + VolumeName string
        + FSType string
        + ReadOnly bool

        + DeepCopyInto(out *ScaleIOPersistentVolumeSource) 
        + DeepCopy() *ScaleIOPersistentVolumeSource

    }
    class ScaleIOVolumeSource << (S,Aquamarine) >> {
        + Gateway string
        + System string
        + SecretRef *LocalObjectReference
        + SSLEnabled bool
        + ProtectionDomain string
        + StoragePool string
        + StorageMode string
        + VolumeName string
        + FSType string
        + ReadOnly bool

        + DeepCopyInto(out *ScaleIOVolumeSource) 
        + DeepCopy() *ScaleIOVolumeSource

    }
    class ScopeSelector << (S,Aquamarine) >> {
        + MatchExpressions []ScopedResourceSelectorRequirement

        + DeepCopyInto(out *ScopeSelector) 
        + DeepCopy() *ScopeSelector

    }
    class ScopedResourceSelectorRequirement << (S,Aquamarine) >> {
        + ScopeName ResourceQuotaScope
        + Operator ScopeSelectorOperator
        + Values []string

        + DeepCopyInto(out *ScopedResourceSelectorRequirement) 
        + DeepCopy() *ScopedResourceSelectorRequirement

    }
    class SeccompProfile << (S,Aquamarine) >> {
        + Type SeccompProfileType
        + LocalhostProfile *string

        + DeepCopyInto(out *SeccompProfile) 
        + DeepCopy() *SeccompProfile

    }
    class Secret << (S,Aquamarine) >> {
        + Immutable *bool
        + Data <font color=blue>map</font>[string][]byte
        + Type SecretType

        + DeepCopyInto(out *Secret) 
        + DeepCopy() *Secret
        + DeepCopyObject() runtime.Object

    }
    class SecretEnvSource << (S,Aquamarine) >> {
        + Optional *bool

        + DeepCopyInto(out *SecretEnvSource) 
        + DeepCopy() *SecretEnvSource

    }
    class SecretKeySelector << (S,Aquamarine) >> {
        + Key string
        + Optional *bool

        + DeepCopyInto(out *SecretKeySelector) 
        + DeepCopy() *SecretKeySelector

    }
    class SecretList << (S,Aquamarine) >> {
        + Items []Secret

        + DeepCopyInto(out *SecretList) 
        + DeepCopy() *SecretList
        + DeepCopyObject() runtime.Object

    }
    class SecretProjection << (S,Aquamarine) >> {
        + Items []KeyToPath
        + Optional *bool

        + DeepCopyInto(out *SecretProjection) 
        + DeepCopy() *SecretProjection

    }
    class SecretReference << (S,Aquamarine) >> {
        + Name string
        + Namespace string

        + DeepCopyInto(out *SecretReference) 
        + DeepCopy() *SecretReference

    }
    class SecretVolumeSource << (S,Aquamarine) >> {
        + SecretName string
        + Items []KeyToPath
        + DefaultMode *int32
        + Optional *bool

        + DeepCopyInto(out *SecretVolumeSource) 
        + DeepCopy() *SecretVolumeSource

    }
    class SecurityContext << (S,Aquamarine) >> {
        + Capabilities *Capabilities
        + Privileged *bool
        + SELinuxOptions *SELinuxOptions
        + WindowsOptions *WindowsSecurityContextOptions
        + RunAsUser *int64
        + RunAsGroup *int64
        + RunAsNonRoot *bool
        + ReadOnlyRootFilesystem *bool
        + AllowPrivilegeEscalation *bool
        + ProcMount *ProcMountType
        + SeccompProfile *SeccompProfile

        + DeepCopyInto(out *SecurityContext) 
        + DeepCopy() *SecurityContext

    }
    class SerializedReference << (S,Aquamarine) >> {
        + Reference ObjectReference

        + DeepCopyInto(out *SerializedReference) 
        + DeepCopy() *SerializedReference
        + DeepCopyObject() runtime.Object

    }
    class Service << (S,Aquamarine) >> {
        + Spec ServiceSpec
        + Status ServiceStatus

        + DeepCopyInto(out *Service) 
        + DeepCopy() *Service
        + DeepCopyObject() runtime.Object

    }
    class ServiceAccount << (S,Aquamarine) >> {
        + Secrets []ObjectReference
        + ImagePullSecrets []LocalObjectReference
        + AutomountServiceAccountToken *bool

        + DeepCopyInto(out *ServiceAccount) 
        + DeepCopy() *ServiceAccount
        + DeepCopyObject() runtime.Object

    }
    class ServiceAccountList << (S,Aquamarine) >> {
        + Items []ServiceAccount

        + DeepCopyInto(out *ServiceAccountList) 
        + DeepCopy() *ServiceAccountList
        + DeepCopyObject() runtime.Object

    }
    class ServiceAccountTokenProjection << (S,Aquamarine) >> {
        + Audience string
        + ExpirationSeconds int64
        + Path string

        + DeepCopyInto(out *ServiceAccountTokenProjection) 
        + DeepCopy() *ServiceAccountTokenProjection

    }
    class ServiceList << (S,Aquamarine) >> {
        + Items []Service

        + DeepCopyInto(out *ServiceList) 
        + DeepCopy() *ServiceList
        + DeepCopyObject() runtime.Object

    }
    class ServicePort << (S,Aquamarine) >> {
        + Name string
        + Protocol Protocol
        + AppProtocol *string
        + Port int32
        + TargetPort intstr.IntOrString
        + NodePort int32

        + DeepCopyInto(out *ServicePort) 
        + DeepCopy() *ServicePort

    }
    class ServiceProxyOptions << (S,Aquamarine) >> {
        + Path string

        + DeepCopyInto(out *ServiceProxyOptions) 
        + DeepCopy() *ServiceProxyOptions
        + DeepCopyObject() runtime.Object

    }
    class ServiceSpec << (S,Aquamarine) >> {
        + Type ServiceType
        + Ports []ServicePort
        + Selector <font color=blue>map</font>[string]string
        + ClusterIP string
        + ClusterIPs []string
        + IPFamilies []IPFamily
        + IPFamilyPolicy *IPFamilyPolicy
        + ExternalName string
        + ExternalIPs []string
        + LoadBalancerIP string
        + SessionAffinity ServiceAffinity
        + SessionAffinityConfig *SessionAffinityConfig
        + LoadBalancerSourceRanges []string
        + ExternalTrafficPolicy ServiceExternalTrafficPolicy
        + HealthCheckNodePort int32
        + PublishNotReadyAddresses bool
        + AllocateLoadBalancerNodePorts *bool
        + LoadBalancerClass *string
        + InternalTrafficPolicy *ServiceInternalTrafficPolicy

        + DeepCopyInto(out *ServiceSpec) 
        + DeepCopy() *ServiceSpec

    }
    class ServiceStatus << (S,Aquamarine) >> {
        + LoadBalancer LoadBalancerStatus
        + Conditions []v1.Condition

        + DeepCopyInto(out *ServiceStatus) 
        + DeepCopy() *ServiceStatus

    }
    class SessionAffinityConfig << (S,Aquamarine) >> {
        + ClientIP *ClientIPConfig

        + DeepCopyInto(out *SessionAffinityConfig) 
        + DeepCopy() *SessionAffinityConfig

    }
    class StorageOSPersistentVolumeSource << (S,Aquamarine) >> {
        + VolumeName string
        + VolumeNamespace string
        + FSType string
        + ReadOnly bool
        + SecretRef *ObjectReference

        + DeepCopyInto(out *StorageOSPersistentVolumeSource) 
        + DeepCopy() *StorageOSPersistentVolumeSource

    }
    class StorageOSVolumeSource << (S,Aquamarine) >> {
        + VolumeName string
        + VolumeNamespace string
        + FSType string
        + ReadOnly bool
        + SecretRef *LocalObjectReference

        + DeepCopyInto(out *StorageOSVolumeSource) 
        + DeepCopy() *StorageOSVolumeSource

    }
    class Sysctl << (S,Aquamarine) >> {
        + Name string
        + Value string

        + DeepCopyInto(out *Sysctl) 
        + DeepCopy() *Sysctl

    }
    class TCPSocketAction << (S,Aquamarine) >> {
        + Port intstr.IntOrString
        + Host string

        + DeepCopyInto(out *TCPSocketAction) 
        + DeepCopy() *TCPSocketAction

    }
    class Taint << (S,Aquamarine) >> {
        + Key string
        + Value string
        + Effect TaintEffect
        + TimeAdded *v1.Time

        + MatchTaint(taintToMatch Taint) bool
        + ToString() string
        + DeepCopyInto(out *Taint) 
        + DeepCopy() *Taint

    }
    class Toleration << (S,Aquamarine) >> {
        + Key string
        + Operator TolerationOperator
        + Value string
        + Effect TaintEffect
        + TolerationSeconds *int64

        + MatchToleration(tolerationToMatch *Toleration) bool
        + DeepCopyInto(out *Toleration) 
        + DeepCopy() *Toleration

    }
    class TopologySelectorLabelRequirement << (S,Aquamarine) >> {
        + Key string
        + Values []string

        + DeepCopyInto(out *TopologySelectorLabelRequirement) 
        + DeepCopy() *TopologySelectorLabelRequirement

    }
    class TopologySelectorTerm << (S,Aquamarine) >> {
        + MatchLabelExpressions []TopologySelectorLabelRequirement

        + DeepCopyInto(out *TopologySelectorTerm) 
        + DeepCopy() *TopologySelectorTerm

    }
    class TopologySpreadConstraint << (S,Aquamarine) >> {
        + MaxSkew int32
        + TopologyKey string
        + WhenUnsatisfiable UnsatisfiableConstraintAction
        + LabelSelector *v1.LabelSelector
        + MinDomains *int32
        + NodeAffinityPolicy *NodeInclusionPolicy
        + NodeTaintsPolicy *NodeInclusionPolicy
        + MatchLabelKeys []string

        + DeepCopyInto(out *TopologySpreadConstraint) 
        + DeepCopy() *TopologySpreadConstraint

    }
    class TypedLocalObjectReference << (S,Aquamarine) >> {
        + APIGroup *string
        + Kind string
        + Name string

        + DeepCopyInto(out *TypedLocalObjectReference) 
        + DeepCopy() *TypedLocalObjectReference

    }
    class TypedObjectReference << (S,Aquamarine) >> {
        + APIGroup *string
        + Kind string
        + Name string
        + Namespace *string

        + DeepCopyInto(out *TypedObjectReference) 
        + DeepCopy() *TypedObjectReference

    }
    class Volume << (S,Aquamarine) >> {
        + Name string

        + DeepCopyInto(out *Volume) 
        + DeepCopy() *Volume

    }
    class VolumeDevice << (S,Aquamarine) >> {
        + Name string
        + DevicePath string

        + DeepCopyInto(out *VolumeDevice) 
        + DeepCopy() *VolumeDevice

    }
    class VolumeMount << (S,Aquamarine) >> {
        + Name string
        + ReadOnly bool
        + MountPath string
        + SubPath string
        + MountPropagation *MountPropagationMode
        + SubPathExpr string

        + DeepCopyInto(out *VolumeMount) 
        + DeepCopy() *VolumeMount

    }
    class VolumeNodeAffinity << (S,Aquamarine) >> {
        + Required *NodeSelector

        + DeepCopyInto(out *VolumeNodeAffinity) 
        + DeepCopy() *VolumeNodeAffinity

    }
    class VolumeProjection << (S,Aquamarine) >> {
        + Secret *SecretProjection
        + DownwardAPI *DownwardAPIProjection
        + ConfigMap *ConfigMapProjection
        + ServiceAccountToken *ServiceAccountTokenProjection

        + DeepCopyInto(out *VolumeProjection) 
        + DeepCopy() *VolumeProjection

    }
    class VolumeSource << (S,Aquamarine) >> {
        + HostPath *HostPathVolumeSource
        + EmptyDir *EmptyDirVolumeSource
        + GCEPersistentDisk *GCEPersistentDiskVolumeSource
        + AWSElasticBlockStore *AWSElasticBlockStoreVolumeSource
        + GitRepo *GitRepoVolumeSource
        + Secret *SecretVolumeSource
        + NFS *NFSVolumeSource
        + ISCSI *ISCSIVolumeSource
        + Glusterfs *GlusterfsVolumeSource
        + PersistentVolumeClaim *PersistentVolumeClaimVolumeSource
        + RBD *RBDVolumeSource
        + Quobyte *QuobyteVolumeSource
        + FlexVolume *FlexVolumeSource
        + Cinder *CinderVolumeSource
        + CephFS *CephFSVolumeSource
        + Flocker *FlockerVolumeSource
        + DownwardAPI *DownwardAPIVolumeSource
        + FC *FCVolumeSource
        + AzureFile *AzureFileVolumeSource
        + ConfigMap *ConfigMapVolumeSource
        + VsphereVolume *VsphereVirtualDiskVolumeSource
        + AzureDisk *AzureDiskVolumeSource
        + PhotonPersistentDisk *PhotonPersistentDiskVolumeSource
        + Projected *ProjectedVolumeSource
        + PortworxVolume *PortworxVolumeSource
        + ScaleIO *ScaleIOVolumeSource
        + StorageOS *StorageOSVolumeSource
        + CSI *CSIVolumeSource
        + Ephemeral *EphemeralVolumeSource

        + DeepCopyInto(out *VolumeSource) 
        + DeepCopy() *VolumeSource

    }
    class VsphereVirtualDiskVolumeSource << (S,Aquamarine) >> {
        + VolumePath string
        + FSType string
        + StoragePolicyName string
        + StoragePolicyID string

        + DeepCopyInto(out *VsphereVirtualDiskVolumeSource) 
        + DeepCopy() *VsphereVirtualDiskVolumeSource

    }
    class WeightedPodAffinityTerm << (S,Aquamarine) >> {
        + Weight int32
        + PodAffinityTerm PodAffinityTerm

        + DeepCopyInto(out *WeightedPodAffinityTerm) 
        + DeepCopy() *WeightedPodAffinityTerm

    }
    class WindowsSecurityContextOptions << (S,Aquamarine) >> {
        + GMSACredentialSpecName *string
        + GMSACredentialSpec *string
        + RunAsUserName *string
        + HostProcess *bool

        + DeepCopyInto(out *WindowsSecurityContextOptions) 
        + DeepCopy() *WindowsSecurityContextOptions

    }
    class core.AzureDataDiskCachingMode << (T, #FF7700) >>  {
    }
    class core.AzureDataDiskKind << (T, #FF7700) >>  {
    }
    class core.Capability << (T, #FF7700) >>  {
    }
    class core.ComponentConditionType << (T, #FF7700) >>  {
    }
    class core.ConditionStatus << (T, #FF7700) >>  {
    }
    class core.DNSPolicy << (T, #FF7700) >>  {
    }
    class core.FinalizerName << (T, #FF7700) >>  {
    }
    class core.HostPathType << (T, #FF7700) >>  {
    }
    class core.IPFamily << (T, #FF7700) >>  {
    }
    class core.IPFamilyPolicy << (T, #FF7700) >>  {
    }
    class core.LimitType << (T, #FF7700) >>  {
    }
    class core.List << (T, #FF7700) >>  {
    }
    class core.MountPropagationMode << (T, #FF7700) >>  {
    }
    class core.NamespaceConditionType << (T, #FF7700) >>  {
    }
    class core.NamespacePhase << (T, #FF7700) >>  {
    }
    class core.NodeAddressType << (T, #FF7700) >>  {
    }
    class core.NodeConditionType << (T, #FF7700) >>  {
    }
    class core.NodeInclusionPolicy << (T, #FF7700) >>  {
    }
    class core.NodePhase << (T, #FF7700) >>  {
    }
    class core.NodeSelectorOperator << (T, #FF7700) >>  {
    }
    class core.OSName << (T, #FF7700) >>  {
    }
    class core.PersistentVolumeAccessMode << (T, #FF7700) >>  {
    }
    class core.PersistentVolumeClaimConditionType << (T, #FF7700) >>  {
    }
    class core.PersistentVolumeClaimPhase << (T, #FF7700) >>  {
    }
    class core.PersistentVolumeClaimResizeStatus << (T, #FF7700) >>  {
    }
    class core.PersistentVolumeMode << (T, #FF7700) >>  {
    }
    class core.PersistentVolumePhase << (T, #FF7700) >>  {
    }
    class core.PersistentVolumeReclaimPolicy << (T, #FF7700) >>  {
    }
    class core.PodConditionType << (T, #FF7700) >>  {
    }
    class core.PodFSGroupChangePolicy << (T, #FF7700) >>  {
    }
    class core.PodPhase << (T, #FF7700) >>  {
    }
    class core.PodQOSClass << (T, #FF7700) >>  {
    }
    class core.PodResizeStatus << (T, #FF7700) >>  {
    }
    class core.PreemptionPolicy << (T, #FF7700) >>  {
    }
    class core.ProcMountType << (T, #FF7700) >>  {
    }
    class core.Protocol << (T, #FF7700) >>  {
    }
    class core.PullPolicy << (T, #FF7700) >>  {
    }
    class core.ReplicationControllerConditionType << (T, #FF7700) >>  {
    }
    class core.ResourceList << (T, #FF7700) >>  {
    }
    class core.ResourceName << (T, #FF7700) >>  {
    }
    class core.ResourceQuotaScope << (T, #FF7700) >>  {
    }
    class core.ResourceResizePolicy << (T, #FF7700) >>  {
    }
    class core.RestartPolicy << (T, #FF7700) >>  {
    }
    class core.ScopeSelectorOperator << (T, #FF7700) >>  {
    }
    class core.SeccompProfileType << (T, #FF7700) >>  {
    }
    class core.SecretType << (T, #FF7700) >>  {
    }
    class core.ServiceAffinity << (T, #FF7700) >>  {
    }
    class core.ServiceExternalTrafficPolicy << (T, #FF7700) >>  {
    }
    class core.ServiceInternalTrafficPolicy << (T, #FF7700) >>  {
    }
    class core.ServiceType << (T, #FF7700) >>  {
    }
    class core.StorageMedium << (T, #FF7700) >>  {
    }
    class core.TaintEffect << (T, #FF7700) >>  {
    }
    class core.TerminationMessagePolicy << (T, #FF7700) >>  {
    }
    class core.TolerationOperator << (T, #FF7700) >>  {
    }
    class core.URIScheme << (T, #FF7700) >>  {
    }
    class core.UniqueVolumeName << (T, #FF7700) >>  {
    }
    class core.UnsatisfiableConstraintAction << (T, #FF7700) >>  {
    }
    class "<font color=blue>map</font>[ResourceName]resource.Quantity" as fontcolorbluemapfontResourceNameresourceQuantity {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "internalversion.List" as internalversionList {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"v1.ObjectMeta" *-- "core.Binding"
"v1.TypeMeta" *-- "core.Binding"
"v1.ObjectMeta" *-- "core.ComponentStatus"
"v1.TypeMeta" *-- "core.ComponentStatus"
"v1.ListMeta" *-- "core.ComponentStatusList"
"v1.TypeMeta" *-- "core.ComponentStatusList"
"v1.ObjectMeta" *-- "core.ConfigMap"
"v1.TypeMeta" *-- "core.ConfigMap"
"core.LocalObjectReference" *-- "core.ConfigMapEnvSource"
"core.LocalObjectReference" *-- "core.ConfigMapKeySelector"
"v1.ListMeta" *-- "core.ConfigMapList"
"v1.TypeMeta" *-- "core.ConfigMapList"
"core.LocalObjectReference" *-- "core.ConfigMapProjection"
"core.LocalObjectReference" *-- "core.ConfigMapVolumeSource"
"v1.ObjectMeta" *-- "core.Endpoints"
"v1.TypeMeta" *-- "core.Endpoints"
"v1.ListMeta" *-- "core.EndpointsList"
"v1.TypeMeta" *-- "core.EndpointsList"
"core.EphemeralContainerCommon" *-- "core.EphemeralContainer"
"v1.ObjectMeta" *-- "core.Event"
"v1.TypeMeta" *-- "core.Event"
"v1.ListMeta" *-- "core.EventList"
"v1.TypeMeta" *-- "core.EventList"
"v1.ObjectMeta" *-- "core.LimitRange"
"v1.TypeMeta" *-- "core.LimitRange"
"v1.ListMeta" *-- "core.LimitRangeList"
"v1.TypeMeta" *-- "core.LimitRangeList"
"v1.ObjectMeta" *-- "core.Namespace"
"v1.TypeMeta" *-- "core.Namespace"
"v1.ListMeta" *-- "core.NamespaceList"
"v1.TypeMeta" *-- "core.NamespaceList"
"v1.ObjectMeta" *-- "core.Node"
"v1.TypeMeta" *-- "core.Node"
"v1.ListMeta" *-- "core.NodeList"
"v1.TypeMeta" *-- "core.NodeList"
"v1.TypeMeta" *-- "core.NodeProxyOptions"
"v1.ObjectMeta" *-- "core.PersistentVolume"
"v1.TypeMeta" *-- "core.PersistentVolume"
"v1.ObjectMeta" *-- "core.PersistentVolumeClaim"
"v1.TypeMeta" *-- "core.PersistentVolumeClaim"
"v1.ListMeta" *-- "core.PersistentVolumeClaimList"
"v1.TypeMeta" *-- "core.PersistentVolumeClaimList"
"v1.ObjectMeta" *-- "core.PersistentVolumeClaimTemplate"
"v1.ListMeta" *-- "core.PersistentVolumeList"
"v1.TypeMeta" *-- "core.PersistentVolumeList"
"core.PersistentVolumeSource" *-- "core.PersistentVolumeSpec"
"v1.ObjectMeta" *-- "core.Pod"
"v1.TypeMeta" *-- "core.Pod"
"v1.TypeMeta" *-- "core.PodAttachOptions"
"v1.TypeMeta" *-- "core.PodExecOptions"
"v1.ListMeta" *-- "core.PodList"
"v1.TypeMeta" *-- "core.PodList"
"v1.TypeMeta" *-- "core.PodLogOptions"
"v1.TypeMeta" *-- "core.PodPortForwardOptions"
"v1.TypeMeta" *-- "core.PodProxyOptions"
"v1.ObjectMeta" *-- "core.PodStatusResult"
"v1.TypeMeta" *-- "core.PodStatusResult"
"v1.ObjectMeta" *-- "core.PodTemplate"
"v1.TypeMeta" *-- "core.PodTemplate"
"v1.ListMeta" *-- "core.PodTemplateList"
"v1.TypeMeta" *-- "core.PodTemplateList"
"v1.ObjectMeta" *-- "core.PodTemplateSpec"
"core.ProbeHandler" *-- "core.Probe"
"v1.ObjectMeta" *-- "core.RangeAllocation"
"v1.TypeMeta" *-- "core.RangeAllocation"
"v1.ObjectMeta" *-- "core.ReplicationController"
"v1.TypeMeta" *-- "core.ReplicationController"
"v1.ListMeta" *-- "core.ReplicationControllerList"
"v1.TypeMeta" *-- "core.ReplicationControllerList"
"v1.ObjectMeta" *-- "core.ResourceQuota"
"v1.TypeMeta" *-- "core.ResourceQuota"
"v1.ListMeta" *-- "core.ResourceQuotaList"
"v1.TypeMeta" *-- "core.ResourceQuotaList"
"v1.ObjectMeta" *-- "core.Secret"
"v1.TypeMeta" *-- "core.Secret"
"core.LocalObjectReference" *-- "core.SecretEnvSource"
"core.LocalObjectReference" *-- "core.SecretKeySelector"
"v1.ListMeta" *-- "core.SecretList"
"v1.TypeMeta" *-- "core.SecretList"
"core.LocalObjectReference" *-- "core.SecretProjection"
"v1.TypeMeta" *-- "core.SerializedReference"
"v1.ObjectMeta" *-- "core.Service"
"v1.TypeMeta" *-- "core.Service"
"v1.ObjectMeta" *-- "core.ServiceAccount"
"v1.TypeMeta" *-- "core.ServiceAccount"
"v1.ListMeta" *-- "core.ServiceAccountList"
"v1.TypeMeta" *-- "core.ServiceAccountList"
"v1.ListMeta" *-- "core.ServiceList"
"v1.TypeMeta" *-- "core.ServiceList"
"v1.TypeMeta" *-- "core.ServiceProxyOptions"
"core.VolumeSource" *-- "core.Volume"


namespace discovery {
    class Endpoint << (S,Aquamarine) >> {
        + Addresses []string
        + Conditions EndpointConditions
        + Hostname *string
        + TargetRef *core.ObjectReference
        + DeprecatedTopology <font color=blue>map</font>[string]string
        + NodeName *string
        + Zone *string
        + Hints *EndpointHints

        + DeepCopyInto(out *Endpoint) 
        + DeepCopy() *Endpoint

    }
    class EndpointConditions << (S,Aquamarine) >> {
        + Ready *bool
        + Serving *bool
        + Terminating *bool

        + DeepCopyInto(out *EndpointConditions) 
        + DeepCopy() *EndpointConditions

    }
    class EndpointHints << (S,Aquamarine) >> {
        + ForZones []ForZone

        + DeepCopyInto(out *EndpointHints) 
        + DeepCopy() *EndpointHints

    }
    class EndpointPort << (S,Aquamarine) >> {
        + Name *string
        + Protocol *core.Protocol
        + Port *int32
        + AppProtocol *string

        + DeepCopyInto(out *EndpointPort) 
        + DeepCopy() *EndpointPort

    }
    class EndpointSlice << (S,Aquamarine) >> {
        + AddressType AddressType
        + Endpoints []Endpoint
        + Ports []EndpointPort

        + DeepCopyInto(out *EndpointSlice) 
        + DeepCopy() *EndpointSlice
        + DeepCopyObject() runtime.Object

    }
    class EndpointSliceList << (S,Aquamarine) >> {
        + Items []EndpointSlice

        + DeepCopyInto(out *EndpointSliceList) 
        + DeepCopy() *EndpointSliceList
        + DeepCopyObject() runtime.Object

    }
    class ForZone << (S,Aquamarine) >> {
        + Name string

        + DeepCopyInto(out *ForZone) 
        + DeepCopy() *ForZone

    }
    class discovery.AddressType << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "discovery.EndpointSlice"
"v1.TypeMeta" *-- "discovery.EndpointSlice"
"v1.ListMeta" *-- "discovery.EndpointSliceList"
"v1.TypeMeta" *-- "discovery.EndpointSliceList"


namespace flowcontrol {
    class FlowDistinguisherMethod << (S,Aquamarine) >> {
        + Type FlowDistinguisherMethodType

        + DeepCopyInto(out *FlowDistinguisherMethod) 
        + DeepCopy() *FlowDistinguisherMethod

    }
    class FlowSchema << (S,Aquamarine) >> {
        + Spec FlowSchemaSpec
        + Status FlowSchemaStatus

        + DeepCopyInto(out *FlowSchema) 
        + DeepCopy() *FlowSchema
        + DeepCopyObject() runtime.Object

    }
    class FlowSchemaCondition << (S,Aquamarine) >> {
        + Type FlowSchemaConditionType
        + Status ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *FlowSchemaCondition) 
        + DeepCopy() *FlowSchemaCondition

    }
    class FlowSchemaList << (S,Aquamarine) >> {
        + Items []FlowSchema

        + DeepCopyInto(out *FlowSchemaList) 
        + DeepCopy() *FlowSchemaList
        + DeepCopyObject() runtime.Object

    }
    class FlowSchemaSpec << (S,Aquamarine) >> {
        + PriorityLevelConfiguration PriorityLevelConfigurationReference
        + MatchingPrecedence int32
        + DistinguisherMethod *FlowDistinguisherMethod
        + Rules []PolicyRulesWithSubjects

        + DeepCopyInto(out *FlowSchemaSpec) 
        + DeepCopy() *FlowSchemaSpec

    }
    class FlowSchemaStatus << (S,Aquamarine) >> {
        + Conditions []FlowSchemaCondition

        + DeepCopyInto(out *FlowSchemaStatus) 
        + DeepCopy() *FlowSchemaStatus

    }
    class GroupSubject << (S,Aquamarine) >> {
        + Name string

        + DeepCopyInto(out *GroupSubject) 
        + DeepCopy() *GroupSubject

    }
    class LimitResponse << (S,Aquamarine) >> {
        + Type LimitResponseType
        + Queuing *QueuingConfiguration

        + DeepCopyInto(out *LimitResponse) 
        + DeepCopy() *LimitResponse

    }
    class LimitedPriorityLevelConfiguration << (S,Aquamarine) >> {
        + NominalConcurrencyShares int32
        + LimitResponse LimitResponse
        + LendablePercent *int32
        + BorrowingLimitPercent *int32

        + DeepCopyInto(out *LimitedPriorityLevelConfiguration) 
        + DeepCopy() *LimitedPriorityLevelConfiguration

    }
    class NonResourcePolicyRule << (S,Aquamarine) >> {
        + Verbs []string
        + NonResourceURLs []string

        + DeepCopyInto(out *NonResourcePolicyRule) 
        + DeepCopy() *NonResourcePolicyRule

    }
    class PolicyRulesWithSubjects << (S,Aquamarine) >> {
        + Subjects []Subject
        + ResourceRules []ResourcePolicyRule
        + NonResourceRules []NonResourcePolicyRule

        + DeepCopyInto(out *PolicyRulesWithSubjects) 
        + DeepCopy() *PolicyRulesWithSubjects

    }
    class PriorityLevelConfiguration << (S,Aquamarine) >> {
        + Spec PriorityLevelConfigurationSpec
        + Status PriorityLevelConfigurationStatus

        + DeepCopyInto(out *PriorityLevelConfiguration) 
        + DeepCopy() *PriorityLevelConfiguration
        + DeepCopyObject() runtime.Object

    }
    class PriorityLevelConfigurationCondition << (S,Aquamarine) >> {
        + Type PriorityLevelConfigurationConditionType
        + Status ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

        + DeepCopyInto(out *PriorityLevelConfigurationCondition) 
        + DeepCopy() *PriorityLevelConfigurationCondition

    }
    class PriorityLevelConfigurationList << (S,Aquamarine) >> {
        + Items []PriorityLevelConfiguration

        + DeepCopyInto(out *PriorityLevelConfigurationList) 
        + DeepCopy() *PriorityLevelConfigurationList
        + DeepCopyObject() runtime.Object

    }
    class PriorityLevelConfigurationReference << (S,Aquamarine) >> {
        + Name string

        + DeepCopyInto(out *PriorityLevelConfigurationReference) 
        + DeepCopy() *PriorityLevelConfigurationReference

    }
    class PriorityLevelConfigurationSpec << (S,Aquamarine) >> {
        + Type PriorityLevelEnablement
        + Limited *LimitedPriorityLevelConfiguration

        + DeepCopyInto(out *PriorityLevelConfigurationSpec) 
        + DeepCopy() *PriorityLevelConfigurationSpec

    }
    class PriorityLevelConfigurationStatus << (S,Aquamarine) >> {
        + Conditions []PriorityLevelConfigurationCondition

        + DeepCopyInto(out *PriorityLevelConfigurationStatus) 
        + DeepCopy() *PriorityLevelConfigurationStatus

    }
    class QueuingConfiguration << (S,Aquamarine) >> {
        + Queues int32
        + HandSize int32
        + QueueLengthLimit int32

        + DeepCopyInto(out *QueuingConfiguration) 
        + DeepCopy() *QueuingConfiguration

    }
    class ResourcePolicyRule << (S,Aquamarine) >> {
        + Verbs []string
        + APIGroups []string
        + Resources []string
        + ClusterScope bool
        + Namespaces []string

        + DeepCopyInto(out *ResourcePolicyRule) 
        + DeepCopy() *ResourcePolicyRule

    }
    class ServiceAccountSubject << (S,Aquamarine) >> {
        + Namespace string
        + Name string

        + DeepCopyInto(out *ServiceAccountSubject) 
        + DeepCopy() *ServiceAccountSubject

    }
    class Subject << (S,Aquamarine) >> {
        + Kind SubjectKind
        + User *UserSubject
        + Group *GroupSubject
        + ServiceAccount *ServiceAccountSubject

        + DeepCopyInto(out *Subject) 
        + DeepCopy() *Subject

    }
    class UserSubject << (S,Aquamarine) >> {
        + Name string

        + DeepCopyInto(out *UserSubject) 
        + DeepCopy() *UserSubject

    }
    class flowcontrol.ConditionStatus << (T, #FF7700) >>  {
    }
    class flowcontrol.FlowDistinguisherMethodType << (T, #FF7700) >>  {
    }
    class flowcontrol.FlowSchemaConditionType << (T, #FF7700) >>  {
    }
    class flowcontrol.LimitResponseType << (T, #FF7700) >>  {
    }
    class flowcontrol.PriorityLevelConfigurationConditionType << (T, #FF7700) >>  {
    }
    class flowcontrol.PriorityLevelEnablement << (T, #FF7700) >>  {
    }
    class flowcontrol.SubjectKind << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "flowcontrol.FlowSchema"
"v1.TypeMeta" *-- "flowcontrol.FlowSchema"
"v1.ListMeta" *-- "flowcontrol.FlowSchemaList"
"v1.TypeMeta" *-- "flowcontrol.FlowSchemaList"
"v1.ObjectMeta" *-- "flowcontrol.PriorityLevelConfiguration"
"v1.TypeMeta" *-- "flowcontrol.PriorityLevelConfiguration"
"v1.ListMeta" *-- "flowcontrol.PriorityLevelConfigurationList"
"v1.TypeMeta" *-- "flowcontrol.PriorityLevelConfigurationList"


namespace imagepolicy {
    class ImageReview << (S,Aquamarine) >> {
        + Spec ImageReviewSpec
        + Status ImageReviewStatus

        + DeepCopyInto(out *ImageReview) 
        + DeepCopy() *ImageReview
        + DeepCopyObject() runtime.Object

    }
    class ImageReviewContainerSpec << (S,Aquamarine) >> {
        + Image string

        + DeepCopyInto(out *ImageReviewContainerSpec) 
        + DeepCopy() *ImageReviewContainerSpec

    }
    class ImageReviewSpec << (S,Aquamarine) >> {
        + Containers []ImageReviewContainerSpec
        + Annotations <font color=blue>map</font>[string]string
        + Namespace string

        + DeepCopyInto(out *ImageReviewSpec) 
        + DeepCopy() *ImageReviewSpec

    }
    class ImageReviewStatus << (S,Aquamarine) >> {
        + Allowed bool
        + Reason string
        + AuditAnnotations <font color=blue>map</font>[string]string

        + DeepCopyInto(out *ImageReviewStatus) 
        + DeepCopy() *ImageReviewStatus

    }
}
"v1.ObjectMeta" *-- "imagepolicy.ImageReview"
"v1.TypeMeta" *-- "imagepolicy.ImageReview"


namespace networking {
    class ClusterCIDR << (S,Aquamarine) >> {
        + Spec ClusterCIDRSpec

        + DeepCopyInto(out *ClusterCIDR) 
        + DeepCopy() *ClusterCIDR
        + DeepCopyObject() runtime.Object

    }
    class ClusterCIDRList << (S,Aquamarine) >> {
        + Items []ClusterCIDR

        + DeepCopyInto(out *ClusterCIDRList) 
        + DeepCopy() *ClusterCIDRList
        + DeepCopyObject() runtime.Object

    }
    class ClusterCIDRSpec << (S,Aquamarine) >> {
        + NodeSelector *core.NodeSelector
        + PerNodeHostBits int32
        + IPv4 string
        + IPv6 string

        + DeepCopyInto(out *ClusterCIDRSpec) 
        + DeepCopy() *ClusterCIDRSpec

    }
    class HTTPIngressPath << (S,Aquamarine) >> {
        + Path string
        + PathType *PathType
        + Backend IngressBackend

        + DeepCopyInto(out *HTTPIngressPath) 
        + DeepCopy() *HTTPIngressPath

    }
    class HTTPIngressRuleValue << (S,Aquamarine) >> {
        + Paths []HTTPIngressPath

        + DeepCopyInto(out *HTTPIngressRuleValue) 
        + DeepCopy() *HTTPIngressRuleValue

    }
    class IPBlock << (S,Aquamarine) >> {
        + CIDR string
        + Except []string

        + DeepCopyInto(out *IPBlock) 
        + DeepCopy() *IPBlock

    }
    class Ingress << (S,Aquamarine) >> {
        + Spec IngressSpec
        + Status IngressStatus

        + DeepCopyInto(out *Ingress) 
        + DeepCopy() *Ingress
        + DeepCopyObject() runtime.Object

    }
    class IngressBackend << (S,Aquamarine) >> {
        + Service *IngressServiceBackend
        + Resource *core.TypedLocalObjectReference

        + DeepCopyInto(out *IngressBackend) 
        + DeepCopy() *IngressBackend

    }
    class IngressClass << (S,Aquamarine) >> {
        + Spec IngressClassSpec

        + DeepCopyInto(out *IngressClass) 
        + DeepCopy() *IngressClass
        + DeepCopyObject() runtime.Object

    }
    class IngressClassList << (S,Aquamarine) >> {
        + Items []IngressClass

        + DeepCopyInto(out *IngressClassList) 
        + DeepCopy() *IngressClassList
        + DeepCopyObject() runtime.Object

    }
    class IngressClassParametersReference << (S,Aquamarine) >> {
        + APIGroup *string
        + Kind string
        + Name string
        + Scope *string
        + Namespace *string

        + DeepCopyInto(out *IngressClassParametersReference) 
        + DeepCopy() *IngressClassParametersReference

    }
    class IngressClassSpec << (S,Aquamarine) >> {
        + Controller string
        + Parameters *IngressClassParametersReference

        + DeepCopyInto(out *IngressClassSpec) 
        + DeepCopy() *IngressClassSpec

    }
    class IngressList << (S,Aquamarine) >> {
        + Items []Ingress

        + DeepCopyInto(out *IngressList) 
        + DeepCopy() *IngressList
        + DeepCopyObject() runtime.Object

    }
    class IngressLoadBalancerIngress << (S,Aquamarine) >> {
        + IP string
        + Hostname string
        + Ports []IngressPortStatus

        + DeepCopyInto(out *IngressLoadBalancerIngress) 
        + DeepCopy() *IngressLoadBalancerIngress

    }
    class IngressLoadBalancerStatus << (S,Aquamarine) >> {
        + Ingress []IngressLoadBalancerIngress

        + DeepCopyInto(out *IngressLoadBalancerStatus) 
        + DeepCopy() *IngressLoadBalancerStatus

    }
    class IngressPortStatus << (S,Aquamarine) >> {
        + Port int32
        + Protocol core.Protocol
        + Error *string

        + DeepCopyInto(out *IngressPortStatus) 
        + DeepCopy() *IngressPortStatus

    }
    class IngressRule << (S,Aquamarine) >> {
        + Host string

        + DeepCopyInto(out *IngressRule) 
        + DeepCopy() *IngressRule

    }
    class IngressRuleValue << (S,Aquamarine) >> {
        + HTTP *HTTPIngressRuleValue

        + DeepCopyInto(out *IngressRuleValue) 
        + DeepCopy() *IngressRuleValue

    }
    class IngressServiceBackend << (S,Aquamarine) >> {
        + Name string
        + Port ServiceBackendPort

        + DeepCopyInto(out *IngressServiceBackend) 
        + DeepCopy() *IngressServiceBackend

    }
    class IngressSpec << (S,Aquamarine) >> {
        + IngressClassName *string
        + DefaultBackend *IngressBackend
        + TLS []IngressTLS
        + Rules []IngressRule

        + DeepCopyInto(out *IngressSpec) 
        + DeepCopy() *IngressSpec

    }
    class IngressStatus << (S,Aquamarine) >> {
        + LoadBalancer IngressLoadBalancerStatus

        + DeepCopyInto(out *IngressStatus) 
        + DeepCopy() *IngressStatus

    }
    class IngressTLS << (S,Aquamarine) >> {
        + Hosts []string
        + SecretName string

        + DeepCopyInto(out *IngressTLS) 
        + DeepCopy() *IngressTLS

    }
    class NetworkPolicy << (S,Aquamarine) >> {
        + Spec NetworkPolicySpec
        + Status NetworkPolicyStatus

        + DeepCopyInto(out *NetworkPolicy) 
        + DeepCopy() *NetworkPolicy
        + DeepCopyObject() runtime.Object

    }
    class NetworkPolicyEgressRule << (S,Aquamarine) >> {
        + Ports []NetworkPolicyPort
        + To []NetworkPolicyPeer

        + DeepCopyInto(out *NetworkPolicyEgressRule) 
        + DeepCopy() *NetworkPolicyEgressRule

    }
    class NetworkPolicyIngressRule << (S,Aquamarine) >> {
        + Ports []NetworkPolicyPort
        + From []NetworkPolicyPeer

        + DeepCopyInto(out *NetworkPolicyIngressRule) 
        + DeepCopy() *NetworkPolicyIngressRule

    }
    class NetworkPolicyList << (S,Aquamarine) >> {
        + Items []NetworkPolicy

        + DeepCopyInto(out *NetworkPolicyList) 
        + DeepCopy() *NetworkPolicyList
        + DeepCopyObject() runtime.Object

    }
    class NetworkPolicyPeer << (S,Aquamarine) >> {
        + PodSelector *v1.LabelSelector
        + NamespaceSelector *v1.LabelSelector
        + IPBlock *IPBlock

        + DeepCopyInto(out *NetworkPolicyPeer) 
        + DeepCopy() *NetworkPolicyPeer

    }
    class NetworkPolicyPort << (S,Aquamarine) >> {
        + Protocol *core.Protocol
        + Port *intstr.IntOrString
        + EndPort *int32

        + DeepCopyInto(out *NetworkPolicyPort) 
        + DeepCopy() *NetworkPolicyPort

    }
    class NetworkPolicySpec << (S,Aquamarine) >> {
        + PodSelector v1.LabelSelector
        + Ingress []NetworkPolicyIngressRule
        + Egress []NetworkPolicyEgressRule
        + PolicyTypes []PolicyType

        + DeepCopyInto(out *NetworkPolicySpec) 
        + DeepCopy() *NetworkPolicySpec

    }
    class NetworkPolicyStatus << (S,Aquamarine) >> {
        + Conditions []v1.Condition

        + DeepCopyInto(out *NetworkPolicyStatus) 
        + DeepCopy() *NetworkPolicyStatus

    }
    class ServiceBackendPort << (S,Aquamarine) >> {
        + Name string
        + Number int32

        + DeepCopyInto(out *ServiceBackendPort) 
        + DeepCopy() *ServiceBackendPort

    }
    class networking.NetworkPolicyConditionReason << (T, #FF7700) >>  {
    }
    class networking.NetworkPolicyConditionType << (T, #FF7700) >>  {
    }
    class networking.PathType << (T, #FF7700) >>  {
    }
    class networking.PolicyType << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "networking.ClusterCIDR"
"v1.TypeMeta" *-- "networking.ClusterCIDR"
"v1.ListMeta" *-- "networking.ClusterCIDRList"
"v1.TypeMeta" *-- "networking.ClusterCIDRList"
"v1.ObjectMeta" *-- "networking.Ingress"
"v1.TypeMeta" *-- "networking.Ingress"
"v1.ObjectMeta" *-- "networking.IngressClass"
"v1.TypeMeta" *-- "networking.IngressClass"
"v1.ListMeta" *-- "networking.IngressClassList"
"v1.TypeMeta" *-- "networking.IngressClassList"
"v1.ListMeta" *-- "networking.IngressList"
"v1.TypeMeta" *-- "networking.IngressList"
"networking.IngressRuleValue" *-- "networking.IngressRule"
"v1.ObjectMeta" *-- "networking.NetworkPolicy"
"v1.TypeMeta" *-- "networking.NetworkPolicy"
"v1.ListMeta" *-- "networking.NetworkPolicyList"
"v1.TypeMeta" *-- "networking.NetworkPolicyList"


namespace node {
    class Overhead << (S,Aquamarine) >> {
        + PodFixed core.ResourceList

        + DeepCopyInto(out *Overhead) 
        + DeepCopy() *Overhead

    }
    class RuntimeClass << (S,Aquamarine) >> {
        + Handler string
        + Overhead *Overhead
        + Scheduling *Scheduling

        + DeepCopyInto(out *RuntimeClass) 
        + DeepCopy() *RuntimeClass
        + DeepCopyObject() runtime.Object

    }
    class RuntimeClassList << (S,Aquamarine) >> {
        + Items []RuntimeClass

        + DeepCopyInto(out *RuntimeClassList) 
        + DeepCopy() *RuntimeClassList
        + DeepCopyObject() runtime.Object

    }
    class Scheduling << (S,Aquamarine) >> {
        + NodeSelector <font color=blue>map</font>[string]string
        + Tolerations []core.Toleration

        + DeepCopyInto(out *Scheduling) 
        + DeepCopy() *Scheduling

    }
}
"v1.ObjectMeta" *-- "node.RuntimeClass"
"v1.TypeMeta" *-- "node.RuntimeClass"
"v1.ListMeta" *-- "node.RuntimeClassList"
"v1.TypeMeta" *-- "node.RuntimeClassList"


namespace pods {
    class pods.ContainerVisitorWithPath << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>(*core.Container, *field.Path) bool" as fontcolorbluefuncfontcoreContainerfieldPathbool {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace policy {
    class AllowedCSIDriver << (S,Aquamarine) >> {
        + Name string

        + DeepCopyInto(out *AllowedCSIDriver) 
        + DeepCopy() *AllowedCSIDriver

    }
    class AllowedFlexVolume << (S,Aquamarine) >> {
        + Driver string

        + DeepCopyInto(out *AllowedFlexVolume) 
        + DeepCopy() *AllowedFlexVolume

    }
    class AllowedHostPath << (S,Aquamarine) >> {
        + PathPrefix string
        + ReadOnly bool

        + DeepCopyInto(out *AllowedHostPath) 
        + DeepCopy() *AllowedHostPath

    }
    class Eviction << (S,Aquamarine) >> {
        + DeleteOptions *v1.DeleteOptions

        + DeepCopyInto(out *Eviction) 
        + DeepCopy() *Eviction
        + DeepCopyObject() runtime.Object

    }
    class FSGroupStrategyOptions << (S,Aquamarine) >> {
        + Rule FSGroupStrategyType
        + Ranges []IDRange

        + DeepCopyInto(out *FSGroupStrategyOptions) 
        + DeepCopy() *FSGroupStrategyOptions

    }
    class HostPortRange << (S,Aquamarine) >> {
        + Min int32
        + Max int32

        + DeepCopyInto(out *HostPortRange) 
        + DeepCopy() *HostPortRange

    }
    class IDRange << (S,Aquamarine) >> {
        + Min int64
        + Max int64

        + DeepCopyInto(out *IDRange) 
        + DeepCopy() *IDRange

    }
    class PodDisruptionBudget << (S,Aquamarine) >> {
        + Spec PodDisruptionBudgetSpec
        + Status PodDisruptionBudgetStatus

        + DeepCopyInto(out *PodDisruptionBudget) 
        + DeepCopy() *PodDisruptionBudget
        + DeepCopyObject() runtime.Object

    }
    class PodDisruptionBudgetList << (S,Aquamarine) >> {
        + Items []PodDisruptionBudget

        + DeepCopyInto(out *PodDisruptionBudgetList) 
        + DeepCopy() *PodDisruptionBudgetList
        + DeepCopyObject() runtime.Object

    }
    class PodDisruptionBudgetSpec << (S,Aquamarine) >> {
        + MinAvailable *intstr.IntOrString
        + Selector *v1.LabelSelector
        + MaxUnavailable *intstr.IntOrString
        + UnhealthyPodEvictionPolicy *UnhealthyPodEvictionPolicyType

        + DeepCopyInto(out *PodDisruptionBudgetSpec) 
        + DeepCopy() *PodDisruptionBudgetSpec

    }
    class PodDisruptionBudgetStatus << (S,Aquamarine) >> {
        + ObservedGeneration int64
        + DisruptedPods <font color=blue>map</font>[string]v1.Time
        + DisruptionsAllowed int32
        + CurrentHealthy int32
        + DesiredHealthy int32
        + ExpectedPods int32
        + Conditions []v1.Condition

        + DeepCopyInto(out *PodDisruptionBudgetStatus) 
        + DeepCopy() *PodDisruptionBudgetStatus

    }
    class PodSecurityPolicy << (S,Aquamarine) >> {
        + Spec PodSecurityPolicySpec

        + DeepCopyInto(out *PodSecurityPolicy) 
        + DeepCopy() *PodSecurityPolicy
        + DeepCopyObject() runtime.Object

    }
    class PodSecurityPolicyList << (S,Aquamarine) >> {
        + Items []PodSecurityPolicy

        + DeepCopyInto(out *PodSecurityPolicyList) 
        + DeepCopy() *PodSecurityPolicyList
        + DeepCopyObject() runtime.Object

    }
    class PodSecurityPolicySpec << (S,Aquamarine) >> {
        + Privileged bool
        + DefaultAddCapabilities []core.Capability
        + RequiredDropCapabilities []core.Capability
        + AllowedCapabilities []core.Capability
        + Volumes []FSType
        + HostNetwork bool
        + HostPorts []HostPortRange
        + HostPID bool
        + HostIPC bool
        + SELinux SELinuxStrategyOptions
        + RunAsUser RunAsUserStrategyOptions
        + RunAsGroup *RunAsGroupStrategyOptions
        + SupplementalGroups SupplementalGroupsStrategyOptions
        + FSGroup FSGroupStrategyOptions
        + ReadOnlyRootFilesystem bool
        + DefaultAllowPrivilegeEscalation *bool
        + AllowPrivilegeEscalation bool
        + AllowedHostPaths []AllowedHostPath
        + AllowedFlexVolumes []AllowedFlexVolume
        + AllowedCSIDrivers []AllowedCSIDriver
        + AllowedUnsafeSysctls []string
        + ForbiddenSysctls []string
        + AllowedProcMountTypes []core.ProcMountType
        + RuntimeClass *RuntimeClassStrategyOptions

        + DeepCopyInto(out *PodSecurityPolicySpec) 
        + DeepCopy() *PodSecurityPolicySpec

    }
    class RunAsGroupStrategyOptions << (S,Aquamarine) >> {
        + Rule RunAsGroupStrategy
        + Ranges []IDRange

        + DeepCopyInto(out *RunAsGroupStrategyOptions) 
        + DeepCopy() *RunAsGroupStrategyOptions

    }
    class RunAsUserStrategyOptions << (S,Aquamarine) >> {
        + Rule RunAsUserStrategy
        + Ranges []IDRange

        + DeepCopyInto(out *RunAsUserStrategyOptions) 
        + DeepCopy() *RunAsUserStrategyOptions

    }
    class RuntimeClassStrategyOptions << (S,Aquamarine) >> {
        + AllowedRuntimeClassNames []string
        + DefaultRuntimeClassName *string

        + DeepCopyInto(out *RuntimeClassStrategyOptions) 
        + DeepCopy() *RuntimeClassStrategyOptions

    }
    class SELinuxStrategyOptions << (S,Aquamarine) >> {
        + Rule SELinuxStrategy
        + SELinuxOptions *core.SELinuxOptions

        + DeepCopyInto(out *SELinuxStrategyOptions) 
        + DeepCopy() *SELinuxStrategyOptions

    }
    class SupplementalGroupsStrategyOptions << (S,Aquamarine) >> {
        + Rule SupplementalGroupsStrategyType
        + Ranges []IDRange

        + DeepCopyInto(out *SupplementalGroupsStrategyOptions) 
        + DeepCopy() *SupplementalGroupsStrategyOptions

    }
    class policy.FSGroupStrategyType << (T, #FF7700) >>  {
    }
    class policy.FSType << (T, #FF7700) >>  {
    }
    class policy.RunAsGroupStrategy << (T, #FF7700) >>  {
    }
    class policy.RunAsUserStrategy << (T, #FF7700) >>  {
    }
    class policy.SELinuxStrategy << (T, #FF7700) >>  {
    }
    class policy.SupplementalGroupsStrategyType << (T, #FF7700) >>  {
    }
    class policy.UnhealthyPodEvictionPolicyType << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "policy.Eviction"
"v1.TypeMeta" *-- "policy.Eviction"
"v1.ObjectMeta" *-- "policy.PodDisruptionBudget"
"v1.TypeMeta" *-- "policy.PodDisruptionBudget"
"v1.ListMeta" *-- "policy.PodDisruptionBudgetList"
"v1.TypeMeta" *-- "policy.PodDisruptionBudgetList"
"v1.ObjectMeta" *-- "policy.PodSecurityPolicy"
"v1.TypeMeta" *-- "policy.PodSecurityPolicy"
"v1.ListMeta" *-- "policy.PodSecurityPolicyList"
"v1.TypeMeta" *-- "policy.PodSecurityPolicyList"


namespace qos {
    class qos.QOSList << (T, #FF7700) >>  {
    }
    class "<font color=blue>map</font>[v1.ResourceName]v1.PodQOSClass" as fontcolorbluemapfontv1ResourceNamev1PodQOSClass {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace rbac {
    class AggregationRule << (S,Aquamarine) >> {
        + ClusterRoleSelectors []v1.LabelSelector

        + DeepCopyInto(out *AggregationRule) 
        + DeepCopy() *AggregationRule

    }
    class ClusterRole << (S,Aquamarine) >> {
        + Rules []PolicyRule
        + AggregationRule *AggregationRule

        + DeepCopyInto(out *ClusterRole) 
        + DeepCopy() *ClusterRole
        + DeepCopyObject() runtime.Object

    }
    class ClusterRoleBinding << (S,Aquamarine) >> {
        + Subjects []Subject
        + RoleRef RoleRef

        + DeepCopyInto(out *ClusterRoleBinding) 
        + DeepCopy() *ClusterRoleBinding
        + DeepCopyObject() runtime.Object

    }
    class ClusterRoleBindingBuilder << (S,Aquamarine) >> {
        + ClusterRoleBinding ClusterRoleBinding

        + Groups(groups ...string) *ClusterRoleBindingBuilder
        + Users(users ...string) *ClusterRoleBindingBuilder
        + SAs(namespace string, serviceAccountNames ...string) *ClusterRoleBindingBuilder
        + BindingOrDie() ClusterRoleBinding
        + Binding() (ClusterRoleBinding, error)

    }
    class ClusterRoleBindingList << (S,Aquamarine) >> {
        + Items []ClusterRoleBinding

        + DeepCopyInto(out *ClusterRoleBindingList) 
        + DeepCopy() *ClusterRoleBindingList
        + DeepCopyObject() runtime.Object

    }
    class ClusterRoleList << (S,Aquamarine) >> {
        + Items []ClusterRole

        + DeepCopyInto(out *ClusterRoleList) 
        + DeepCopy() *ClusterRoleList
        + DeepCopyObject() runtime.Object

    }
    class PolicyRule << (S,Aquamarine) >> {
        + Verbs []string
        + APIGroups []string
        + Resources []string
        + ResourceNames []string
        + NonResourceURLs []string

        + String() string
        + CompactString() string
        + DeepCopyInto(out *PolicyRule) 
        + DeepCopy() *PolicyRule

    }
    class PolicyRuleBuilder << (S,Aquamarine) >> {
        + PolicyRule PolicyRule

        + Groups(groups ...string) *PolicyRuleBuilder
        + Resources(resources ...string) *PolicyRuleBuilder
        + Names(names ...string) *PolicyRuleBuilder
        + URLs(urls ...string) *PolicyRuleBuilder
        + RuleOrDie() PolicyRule
        + Rule() (PolicyRule, error)

    }
    class Role << (S,Aquamarine) >> {
        + Rules []PolicyRule

        + DeepCopyInto(out *Role) 
        + DeepCopy() *Role
        + DeepCopyObject() runtime.Object

    }
    class RoleBinding << (S,Aquamarine) >> {
        + Subjects []Subject
        + RoleRef RoleRef

        + DeepCopyInto(out *RoleBinding) 
        + DeepCopy() *RoleBinding
        + DeepCopyObject() runtime.Object

    }
    class RoleBindingBuilder << (S,Aquamarine) >> {
        + RoleBinding RoleBinding

        + Groups(groups ...string) *RoleBindingBuilder
        + Users(users ...string) *RoleBindingBuilder
        + SAs(namespace string, serviceAccountNames ...string) *RoleBindingBuilder
        + BindingOrDie() RoleBinding
        + Binding() (RoleBinding, error)

    }
    class RoleBindingList << (S,Aquamarine) >> {
        + Items []RoleBinding

        + DeepCopyInto(out *RoleBindingList) 
        + DeepCopy() *RoleBindingList
        + DeepCopyObject() runtime.Object

    }
    class RoleList << (S,Aquamarine) >> {
        + Items []Role

        + DeepCopyInto(out *RoleList) 
        + DeepCopy() *RoleList
        + DeepCopyObject() runtime.Object

    }
    class RoleRef << (S,Aquamarine) >> {
        + APIGroup string
        + Kind string
        + Name string

        + DeepCopyInto(out *RoleRef) 
        + DeepCopy() *RoleRef

    }
    class SortableRuleSlice << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool
        + DeepCopyInto(out *SortableRuleSlice) 
        + DeepCopy() SortableRuleSlice

    }
    class Subject << (S,Aquamarine) >> {
        + Kind string
        + APIGroup string
        + Name string
        + Namespace string

        + DeepCopyInto(out *Subject) 
        + DeepCopy() *Subject

    }
    class rbac.SortableRuleSlice << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "rbac.ClusterRole"
"v1.TypeMeta" *-- "rbac.ClusterRole"
"v1.ObjectMeta" *-- "rbac.ClusterRoleBinding"
"v1.TypeMeta" *-- "rbac.ClusterRoleBinding"
"v1.ListMeta" *-- "rbac.ClusterRoleBindingList"
"v1.TypeMeta" *-- "rbac.ClusterRoleBindingList"
"v1.ListMeta" *-- "rbac.ClusterRoleList"
"v1.TypeMeta" *-- "rbac.ClusterRoleList"
"v1.ObjectMeta" *-- "rbac.Role"
"v1.TypeMeta" *-- "rbac.Role"
"v1.ObjectMeta" *-- "rbac.RoleBinding"
"v1.TypeMeta" *-- "rbac.RoleBinding"
"v1.ListMeta" *-- "rbac.RoleBindingList"
"v1.TypeMeta" *-- "rbac.RoleBindingList"
"v1.ListMeta" *-- "rbac.RoleList"
"v1.TypeMeta" *-- "rbac.RoleList"


namespace resource {
    class AllocationResult << (S,Aquamarine) >> {
        + ResourceHandle string
        + AvailableOnNodes *core.NodeSelector
        + Shareable bool

        + DeepCopyInto(out *AllocationResult) 
        + DeepCopy() *AllocationResult

    }
    class PodScheduling << (S,Aquamarine) >> {
        + Spec PodSchedulingSpec
        + Status PodSchedulingStatus

        + DeepCopyInto(out *PodScheduling) 
        + DeepCopy() *PodScheduling
        + DeepCopyObject() runtime.Object

    }
    class PodSchedulingList << (S,Aquamarine) >> {
        + Items []PodScheduling

        + DeepCopyInto(out *PodSchedulingList) 
        + DeepCopy() *PodSchedulingList
        + DeepCopyObject() runtime.Object

    }
    class PodSchedulingSpec << (S,Aquamarine) >> {
        + SelectedNode string
        + PotentialNodes []string

        + DeepCopyInto(out *PodSchedulingSpec) 
        + DeepCopy() *PodSchedulingSpec

    }
    class PodSchedulingStatus << (S,Aquamarine) >> {
        + ResourceClaims []ResourceClaimSchedulingStatus

        + DeepCopyInto(out *PodSchedulingStatus) 
        + DeepCopy() *PodSchedulingStatus

    }
    class ResourceClaim << (S,Aquamarine) >> {
        + Spec ResourceClaimSpec
        + Status ResourceClaimStatus

        + DeepCopyInto(out *ResourceClaim) 
        + DeepCopy() *ResourceClaim
        + DeepCopyObject() runtime.Object

    }
    class ResourceClaimConsumerReference << (S,Aquamarine) >> {
        + APIGroup string
        + Resource string
        + Name string
        + UID types.UID

        + DeepCopyInto(out *ResourceClaimConsumerReference) 
        + DeepCopy() *ResourceClaimConsumerReference

    }
    class ResourceClaimList << (S,Aquamarine) >> {
        + Items []ResourceClaim

        + DeepCopyInto(out *ResourceClaimList) 
        + DeepCopy() *ResourceClaimList
        + DeepCopyObject() runtime.Object

    }
    class ResourceClaimParametersReference << (S,Aquamarine) >> {
        + APIGroup string
        + Kind string
        + Name string

        + DeepCopyInto(out *ResourceClaimParametersReference) 
        + DeepCopy() *ResourceClaimParametersReference

    }
    class ResourceClaimSchedulingStatus << (S,Aquamarine) >> {
        + Name string
        + UnsuitableNodes []string

        + DeepCopyInto(out *ResourceClaimSchedulingStatus) 
        + DeepCopy() *ResourceClaimSchedulingStatus

    }
    class ResourceClaimSpec << (S,Aquamarine) >> {
        + ResourceClassName string
        + ParametersRef *ResourceClaimParametersReference
        + AllocationMode AllocationMode

        + DeepCopyInto(out *ResourceClaimSpec) 
        + DeepCopy() *ResourceClaimSpec

    }
    class ResourceClaimStatus << (S,Aquamarine) >> {
        + DriverName string
        + Allocation *AllocationResult
        + ReservedFor []ResourceClaimConsumerReference
        + DeallocationRequested bool

        + DeepCopyInto(out *ResourceClaimStatus) 
        + DeepCopy() *ResourceClaimStatus

    }
    class ResourceClaimTemplate << (S,Aquamarine) >> {
        + Spec ResourceClaimTemplateSpec

        + DeepCopyInto(out *ResourceClaimTemplate) 
        + DeepCopy() *ResourceClaimTemplate
        + DeepCopyObject() runtime.Object

    }
    class ResourceClaimTemplateList << (S,Aquamarine) >> {
        + Items []ResourceClaimTemplate

        + DeepCopyInto(out *ResourceClaimTemplateList) 
        + DeepCopy() *ResourceClaimTemplateList
        + DeepCopyObject() runtime.Object

    }
    class ResourceClaimTemplateSpec << (S,Aquamarine) >> {
        + Spec ResourceClaimSpec

        + DeepCopyInto(out *ResourceClaimTemplateSpec) 
        + DeepCopy() *ResourceClaimTemplateSpec

    }
    class ResourceClass << (S,Aquamarine) >> {
        + DriverName string
        + ParametersRef *ResourceClassParametersReference
        + SuitableNodes *core.NodeSelector

        + DeepCopyInto(out *ResourceClass) 
        + DeepCopy() *ResourceClass
        + DeepCopyObject() runtime.Object

    }
    class ResourceClassList << (S,Aquamarine) >> {
        + Items []ResourceClass

        + DeepCopyInto(out *ResourceClassList) 
        + DeepCopy() *ResourceClassList
        + DeepCopyObject() runtime.Object

    }
    class ResourceClassParametersReference << (S,Aquamarine) >> {
        + APIGroup string
        + Kind string
        + Name string
        + Namespace string

        + DeepCopyInto(out *ResourceClassParametersReference) 
        + DeepCopy() *ResourceClassParametersReference

    }
    class resource.AllocationMode << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "resource.PodScheduling"
"v1.TypeMeta" *-- "resource.PodScheduling"
"v1.ListMeta" *-- "resource.PodSchedulingList"
"v1.TypeMeta" *-- "resource.PodSchedulingList"
"v1.ObjectMeta" *-- "resource.ResourceClaim"
"v1.TypeMeta" *-- "resource.ResourceClaim"
"v1.ListMeta" *-- "resource.ResourceClaimList"
"v1.TypeMeta" *-- "resource.ResourceClaimList"
"v1.ObjectMeta" *-- "resource.ResourceClaimTemplate"
"v1.TypeMeta" *-- "resource.ResourceClaimTemplate"
"v1.ListMeta" *-- "resource.ResourceClaimTemplateList"
"v1.TypeMeta" *-- "resource.ResourceClaimTemplateList"
"v1.ObjectMeta" *-- "resource.ResourceClaimTemplateSpec"
"v1.ObjectMeta" *-- "resource.ResourceClass"
"v1.TypeMeta" *-- "resource.ResourceClass"
"v1.ListMeta" *-- "resource.ResourceClassList"
"v1.TypeMeta" *-- "resource.ResourceClassList"


namespace scheduling {
    class PriorityClass << (S,Aquamarine) >> {
        + Value int32
        + GlobalDefault bool
        + Description string
        + PreemptionPolicy *core.PreemptionPolicy

        + DeepCopyInto(out *PriorityClass) 
        + DeepCopy() *PriorityClass
        + DeepCopyObject() runtime.Object

    }
    class PriorityClassList << (S,Aquamarine) >> {
        + Items []PriorityClass

        + DeepCopyInto(out *PriorityClassList) 
        + DeepCopy() *PriorityClassList
        + DeepCopyObject() runtime.Object

    }
}
"v1.ObjectMeta" *-- "scheduling.PriorityClass"
"v1.TypeMeta" *-- "scheduling.PriorityClass"
"v1.ListMeta" *-- "scheduling.PriorityClassList"
"v1.TypeMeta" *-- "scheduling.PriorityClassList"


namespace storage {
    class CSIDriver << (S,Aquamarine) >> {
        + Spec CSIDriverSpec

        + DeepCopyInto(out *CSIDriver) 
        + DeepCopy() *CSIDriver
        + DeepCopyObject() runtime.Object

    }
    class CSIDriverList << (S,Aquamarine) >> {
        + Items []CSIDriver

        + DeepCopyInto(out *CSIDriverList) 
        + DeepCopy() *CSIDriverList
        + DeepCopyObject() runtime.Object

    }
    class CSIDriverSpec << (S,Aquamarine) >> {
        + AttachRequired *bool
        + FSGroupPolicy *FSGroupPolicy
        + PodInfoOnMount *bool
        + VolumeLifecycleModes []VolumeLifecycleMode
        + StorageCapacity *bool
        + TokenRequests []TokenRequest
        + RequiresRepublish *bool
        + SELinuxMount *bool

        + DeepCopyInto(out *CSIDriverSpec) 
        + DeepCopy() *CSIDriverSpec

    }
    class CSINode << (S,Aquamarine) >> {
        + Spec CSINodeSpec

        + DeepCopyInto(out *CSINode) 
        + DeepCopy() *CSINode
        + DeepCopyObject() runtime.Object

    }
    class CSINodeDriver << (S,Aquamarine) >> {
        + Name string
        + NodeID string
        + TopologyKeys []string
        + Allocatable *VolumeNodeResources

        + DeepCopyInto(out *CSINodeDriver) 
        + DeepCopy() *CSINodeDriver

    }
    class CSINodeList << (S,Aquamarine) >> {
        + Items []CSINode

        + DeepCopyInto(out *CSINodeList) 
        + DeepCopy() *CSINodeList
        + DeepCopyObject() runtime.Object

    }
    class CSINodeSpec << (S,Aquamarine) >> {
        + Drivers []CSINodeDriver

        + DeepCopyInto(out *CSINodeSpec) 
        + DeepCopy() *CSINodeSpec

    }
    class CSIStorageCapacity << (S,Aquamarine) >> {
        + NodeTopology *v1.LabelSelector
        + StorageClassName string
        + Capacity *resource.Quantity
        + MaximumVolumeSize *resource.Quantity

        + DeepCopyInto(out *CSIStorageCapacity) 
        + DeepCopy() *CSIStorageCapacity
        + DeepCopyObject() runtime.Object

    }
    class CSIStorageCapacityList << (S,Aquamarine) >> {
        + Items []CSIStorageCapacity

        + DeepCopyInto(out *CSIStorageCapacityList) 
        + DeepCopy() *CSIStorageCapacityList
        + DeepCopyObject() runtime.Object

    }
    class StorageClass << (S,Aquamarine) >> {
        + Provisioner string
        + Parameters <font color=blue>map</font>[string]string
        + ReclaimPolicy *core.PersistentVolumeReclaimPolicy
        + MountOptions []string
        + AllowVolumeExpansion *bool
        + VolumeBindingMode *VolumeBindingMode
        + AllowedTopologies []core.TopologySelectorTerm

        + DeepCopyInto(out *StorageClass) 
        + DeepCopy() *StorageClass
        + DeepCopyObject() runtime.Object

    }
    class StorageClassList << (S,Aquamarine) >> {
        + Items []StorageClass

        + DeepCopyInto(out *StorageClassList) 
        + DeepCopy() *StorageClassList
        + DeepCopyObject() runtime.Object

    }
    class TokenRequest << (S,Aquamarine) >> {
        + Audience string
        + ExpirationSeconds *int64

        + DeepCopyInto(out *TokenRequest) 
        + DeepCopy() *TokenRequest

    }
    class VolumeAttachment << (S,Aquamarine) >> {
        + Spec VolumeAttachmentSpec
        + Status VolumeAttachmentStatus

        + DeepCopyInto(out *VolumeAttachment) 
        + DeepCopy() *VolumeAttachment
        + DeepCopyObject() runtime.Object

    }
    class VolumeAttachmentList << (S,Aquamarine) >> {
        + Items []VolumeAttachment

        + DeepCopyInto(out *VolumeAttachmentList) 
        + DeepCopy() *VolumeAttachmentList
        + DeepCopyObject() runtime.Object

    }
    class VolumeAttachmentSource << (S,Aquamarine) >> {
        + PersistentVolumeName *string
        + InlineVolumeSpec *core.PersistentVolumeSpec

        + DeepCopyInto(out *VolumeAttachmentSource) 
        + DeepCopy() *VolumeAttachmentSource

    }
    class VolumeAttachmentSpec << (S,Aquamarine) >> {
        + Attacher string
        + Source VolumeAttachmentSource
        + NodeName string

        + DeepCopyInto(out *VolumeAttachmentSpec) 
        + DeepCopy() *VolumeAttachmentSpec

    }
    class VolumeAttachmentStatus << (S,Aquamarine) >> {
        + Attached bool
        + AttachmentMetadata <font color=blue>map</font>[string]string
        + AttachError *VolumeError
        + DetachError *VolumeError

        + DeepCopyInto(out *VolumeAttachmentStatus) 
        + DeepCopy() *VolumeAttachmentStatus

    }
    class VolumeError << (S,Aquamarine) >> {
        + Time v1.Time
        + Message string

        + DeepCopyInto(out *VolumeError) 
        + DeepCopy() *VolumeError

    }
    class VolumeNodeResources << (S,Aquamarine) >> {
        + Count *int32

        + DeepCopyInto(out *VolumeNodeResources) 
        + DeepCopy() *VolumeNodeResources

    }
    class storage.FSGroupPolicy << (T, #FF7700) >>  {
    }
    class storage.VolumeBindingMode << (T, #FF7700) >>  {
    }
    class storage.VolumeLifecycleMode << (T, #FF7700) >>  {
    }
}
"v1.ObjectMeta" *-- "storage.CSIDriver"
"v1.TypeMeta" *-- "storage.CSIDriver"
"v1.ListMeta" *-- "storage.CSIDriverList"
"v1.TypeMeta" *-- "storage.CSIDriverList"
"v1.ObjectMeta" *-- "storage.CSINode"
"v1.TypeMeta" *-- "storage.CSINode"
"v1.ListMeta" *-- "storage.CSINodeList"
"v1.TypeMeta" *-- "storage.CSINodeList"
"v1.ObjectMeta" *-- "storage.CSIStorageCapacity"
"v1.TypeMeta" *-- "storage.CSIStorageCapacity"
"v1.ListMeta" *-- "storage.CSIStorageCapacityList"
"v1.TypeMeta" *-- "storage.CSIStorageCapacityList"
"v1.ObjectMeta" *-- "storage.StorageClass"
"v1.TypeMeta" *-- "storage.StorageClass"
"v1.ListMeta" *-- "storage.StorageClassList"
"v1.TypeMeta" *-- "storage.StorageClassList"
"v1.ObjectMeta" *-- "storage.VolumeAttachment"
"v1.TypeMeta" *-- "storage.VolumeAttachment"
"v1.ListMeta" *-- "storage.VolumeAttachmentList"
"v1.TypeMeta" *-- "storage.VolumeAttachmentList"


namespace util {
    class FlowSchemaSequence << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class util.FlowSchemaSequence << (T, #FF7700) >>  {
    }
    class "[]*flowcontrol.FlowSchema" as flowcontrolFlowSchema {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace v0 {
    class Policy << (S,Aquamarine) >> {
        + User string
        + Group string
        + Readonly bool
        + Resource string
        + Namespace string

        + DeepCopyInto(out *Policy) 
        + DeepCopy() *Policy
        + DeepCopyObject() runtime.Object

    }
}
"v1.TypeMeta" *-- "v0.Policy"


namespace v1 {
    class ClusterRoleBindingBuilder << (S,Aquamarine) >> {
        + ClusterRoleBinding v1.ClusterRoleBinding

        + Groups(groups ...string) *ClusterRoleBindingBuilder
        + Users(users ...string) *ClusterRoleBindingBuilder
        + SAs(namespace string, serviceAccountNames ...string) *ClusterRoleBindingBuilder
        + BindingOrDie() v1.ClusterRoleBinding
        + Binding() (v1.ClusterRoleBinding, error)

    }
    class PolicyRuleBuilder << (S,Aquamarine) >> {
        + PolicyRule v1.PolicyRule

        + Groups(groups ...string) *PolicyRuleBuilder
        + Resources(resources ...string) *PolicyRuleBuilder
        + Names(names ...string) *PolicyRuleBuilder
        + URLs(urls ...string) *PolicyRuleBuilder
        + RuleOrDie() v1.PolicyRule
        + Rule() (v1.PolicyRule, error)

    }
    class RoleBindingBuilder << (S,Aquamarine) >> {
        + RoleBinding v1.RoleBinding

        + Groups(groups ...string) *RoleBindingBuilder
        + Users(users ...string) *RoleBindingBuilder
        + SAs(namespace string, serviceAccountNames ...string) *RoleBindingBuilder
        + BindingOrDie() v1.RoleBinding
        + Binding() (v1.RoleBinding, error)

    }
    class SortableRuleSlice << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool
        + DeepCopyInto(out *SortableRuleSlice) 
        + DeepCopy() SortableRuleSlice

    }
    class v1.SortableRuleSlice << (T, #FF7700) >>  {
    }
    class "[]v1.PolicyRule" as v1PolicyRule {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace v1alpha1 {
    class ClusterRoleBindingBuilder << (S,Aquamarine) >> {
        + ClusterRoleBinding v1alpha1.ClusterRoleBinding

        + Groups(groups ...string) *ClusterRoleBindingBuilder
        + Users(users ...string) *ClusterRoleBindingBuilder
        + SAs(namespace string, serviceAccountNames ...string) *ClusterRoleBindingBuilder
        + BindingOrDie() v1alpha1.ClusterRoleBinding
        + Binding() (v1alpha1.ClusterRoleBinding, error)

    }
    class PolicyRuleBuilder << (S,Aquamarine) >> {
        + PolicyRule v1alpha1.PolicyRule

        + Groups(groups ...string) *PolicyRuleBuilder
        + Resources(resources ...string) *PolicyRuleBuilder
        + Names(names ...string) *PolicyRuleBuilder
        + URLs(urls ...string) *PolicyRuleBuilder
        + RuleOrDie() v1alpha1.PolicyRule
        + Rule() (v1alpha1.PolicyRule, error)

    }
}


namespace v1beta1 {
    class ClusterRoleBindingBuilder << (S,Aquamarine) >> {
        + ClusterRoleBinding v1beta1.ClusterRoleBinding

        + Groups(groups ...string) *ClusterRoleBindingBuilder
        + Users(users ...string) *ClusterRoleBindingBuilder
        + SAs(namespace string, serviceAccountNames ...string) *ClusterRoleBindingBuilder
        + BindingOrDie() v1beta1.ClusterRoleBinding
        + Binding() (v1beta1.ClusterRoleBinding, error)

    }
    class Policy << (S,Aquamarine) >> {
        + Spec PolicySpec

        + DeepCopyInto(out *Policy) 
        + DeepCopy() *Policy
        + DeepCopyObject() runtime.Object

    }
    class PolicyRuleBuilder << (S,Aquamarine) >> {
        + PolicyRule v1beta1.PolicyRule

        + Groups(groups ...string) *PolicyRuleBuilder
        + Resources(resources ...string) *PolicyRuleBuilder
        + Names(names ...string) *PolicyRuleBuilder
        + URLs(urls ...string) *PolicyRuleBuilder
        + RuleOrDie() v1beta1.PolicyRule
        + Rule() (v1beta1.PolicyRule, error)

    }
    class PolicySpec << (S,Aquamarine) >> {
        + User string
        + Group string
        + Readonly bool
        + APIGroup string
        + Resource string
        + Namespace string
        + NonResourcePath string

        + DeepCopyInto(out *PolicySpec) 
        + DeepCopy() *PolicySpec

    }
}
"v1.TypeMeta" *-- "v1beta1.Policy"


namespace validation {
    class CSINodeValidationOptions << (S,Aquamarine) >> {
        + AllowLongNodeID bool

    }
    class CSIStorageCapacityValidateOptions << (S,Aquamarine) >> {
        + AllowInvalidLabelValueInSelector bool

    }
    class ClusterRoleValidationOptions << (S,Aquamarine) >> {
        + AllowInvalidLabelValueInSelector bool

    }
    class IngressValidationOptions << (S,Aquamarine) >> {
        + AllowInvalidSecretName bool
        + AllowInvalidWildcardHostRule bool

    }
    class JobValidationOptions << (S,Aquamarine) >> {
        + AllowTrackingAnnotation bool
        + AllowMutableSchedulingDirectives bool
        + AllowElasticIndexedJobs bool

    }
    class NetworkPolicyValidationOptions << (S,Aquamarine) >> {
        + AllowInvalidLabelValueInSelector bool

    }
    class PersistentVolumeClaimSpecValidationOptions << (S,Aquamarine) >> {
        + AllowReadWriteOncePod bool
        + EnableRecoverFromExpansionFailure bool
        + EnableRetroactiveDefaultStorageClass bool
        + AllowInvalidLabelValueInSelector bool

    }
    class PersistentVolumeSpecValidationOptions << (S,Aquamarine) >> {
        + AllowReadWriteOncePod bool

    }
    class PodDisruptionBudgetValidationOptions << (S,Aquamarine) >> {
        + AllowInvalidLabelValueInSelector bool

    }
    class PodValidationOptions << (S,Aquamarine) >> {
        + AllowInvalidPodDeletionCost bool
        + AllowInvalidLabelValueInSelector bool
        + AllowIndivisibleHugePagesValues bool
        + AllowExpandedDNSConfig bool
        + AllowInvalidTopologySpreadConstraintLabelSelector bool

    }
    class certificateValidationOptions << (S,Aquamarine) >> {
        - allowSettingApprovalConditions bool
        - allowSettingCertificate bool
        - allowBothApprovedAndDenied bool
        - allowResettingCertificate bool
        - allowLegacySignerName bool
        - allowDuplicateConditionTypes bool
        - allowEmptyConditionType bool
        - allowArbitraryCertificate bool
        - allowUnknownUsages bool
        - allowDuplicateUsages bool

    }
    class commonHandler << (S,Aquamarine) >> {
        + Exec *core.ExecAction
        + HTTPGet *core.HTTPGetAction
        + TCPSocket *core.TCPSocketAction
        + GRPC *core.GRPCAction

    }
    class groupVersion << (S,Aquamarine) >> {
        + Group string
        + Version string

    }
    class validation.ValidateNameFunc << (T, #FF7700) >>  {
    }
    class validationOptions << (S,Aquamarine) >> {
        - requireNoSideEffects bool
        - requireRecognizedAdmissionReviewVersion bool
        - requireUniqueWebhookNames bool
        - allowInvalidLabelValueInSelector bool

    }
    class "validation.ValidateNameFunc" as validationValidateNameFunc {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"validation.PodValidationOptions" *-- "validation.JobValidationOptions"


"__builtin__.[]string" #.. "authentication.ExtraValue"
"__builtin__.[]string" #.. "authorization.ExtraValue"
"__builtin__.[]string" #.. "certificates.ExtraValue"
"__builtin__.string" #.. "admission.Operation"
"__builtin__.string" #.. "admission.PatchType"
"__builtin__.string" #.. "admissionregistration.FailurePolicyType"
"__builtin__.string" #.. "admissionregistration.MatchPolicyType"
"__builtin__.string" #.. "admissionregistration.OperationType"
"__builtin__.string" #.. "admissionregistration.ReinvocationPolicyType"
"__builtin__.string" #.. "admissionregistration.ScopeType"
"__builtin__.string" #.. "admissionregistration.SideEffectClass"
"__builtin__.string" #.. "apidiscovery.DiscoveryFreshness"
"__builtin__.string" #.. "apidiscovery.ResourceScope"
"__builtin__.string" #.. "apiserverinternal.ConditionStatus"
"__builtin__.string" #.. "apiserverinternal.StorageVersionConditionType"
"__builtin__.string" #.. "apps.DaemonSetConditionType"
"__builtin__.string" #.. "apps.DaemonSetUpdateStrategyType"
"__builtin__.string" #.. "apps.DeploymentConditionType"
"__builtin__.string" #.. "apps.DeploymentStrategyType"
"__builtin__.string" #.. "apps.PersistentVolumeClaimRetentionPolicyType"
"__builtin__.string" #.. "apps.PodManagementPolicyType"
"__builtin__.string" #.. "apps.ReplicaSetConditionType"
"__builtin__.string" #.. "apps.StatefulSetConditionType"
"__builtin__.string" #.. "apps.StatefulSetUpdateStrategyType"
"__builtin__.string" #.. "autoscaling.ConditionStatus"
"__builtin__.string" #.. "autoscaling.HPAScalingPolicyType"
"__builtin__.string" #.. "autoscaling.HorizontalPodAutoscalerConditionType"
"__builtin__.string" #.. "autoscaling.MetricSourceType"
"__builtin__.string" #.. "autoscaling.MetricTargetType"
"__builtin__.string" #.. "autoscaling.ScalingPolicySelect"
"__builtin__.string" #.. "batch.CompletionMode"
"__builtin__.string" #.. "batch.ConcurrencyPolicy"
"__builtin__.string" #.. "batch.JobConditionType"
"__builtin__.string" #.. "batch.PodFailurePolicyAction"
"__builtin__.string" #.. "batch.PodFailurePolicyOnExitCodesOperator"
"__builtin__.string" #.. "certificates.KeyUsage"
"__builtin__.string" #.. "certificates.RequestConditionType"
"__builtin__.string" #.. "core.AzureDataDiskCachingMode"
"__builtin__.string" #.. "core.AzureDataDiskKind"
"__builtin__.string" #.. "core.Capability"
"__builtin__.string" #.. "core.ComponentConditionType"
"__builtin__.string" #.. "core.ConditionStatus"
"__builtin__.string" #.. "core.DNSPolicy"
"__builtin__.string" #.. "core.FinalizerName"
"__builtin__.string" #.. "core.HostPathType"
"__builtin__.string" #.. "core.IPFamily"
"__builtin__.string" #.. "core.IPFamilyPolicy"
"__builtin__.string" #.. "core.LimitType"
"__builtin__.string" #.. "core.MountPropagationMode"
"__builtin__.string" #.. "core.NamespaceConditionType"
"__builtin__.string" #.. "core.NamespacePhase"
"__builtin__.string" #.. "core.NodeAddressType"
"__builtin__.string" #.. "core.NodeConditionType"
"__builtin__.string" #.. "core.NodeInclusionPolicy"
"__builtin__.string" #.. "core.NodePhase"
"__builtin__.string" #.. "core.NodeSelectorOperator"
"__builtin__.string" #.. "core.OSName"
"__builtin__.string" #.. "core.PersistentVolumeAccessMode"
"__builtin__.string" #.. "core.PersistentVolumeClaimConditionType"
"__builtin__.string" #.. "core.PersistentVolumeClaimPhase"
"__builtin__.string" #.. "core.PersistentVolumeClaimResizeStatus"
"__builtin__.string" #.. "core.PersistentVolumeMode"
"__builtin__.string" #.. "core.PersistentVolumePhase"
"__builtin__.string" #.. "core.PersistentVolumeReclaimPolicy"
"__builtin__.string" #.. "core.PodConditionType"
"__builtin__.string" #.. "core.PodFSGroupChangePolicy"
"__builtin__.string" #.. "core.PodPhase"
"__builtin__.string" #.. "core.PodQOSClass"
"__builtin__.string" #.. "core.PodResizeStatus"
"__builtin__.string" #.. "core.PreemptionPolicy"
"__builtin__.string" #.. "core.ProcMountType"
"__builtin__.string" #.. "core.Protocol"
"__builtin__.string" #.. "core.PullPolicy"
"__builtin__.string" #.. "core.ReplicationControllerConditionType"
"__builtin__.string" #.. "core.ResourceName"
"__builtin__.string" #.. "core.ResourceQuotaScope"
"__builtin__.string" #.. "core.ResourceResizePolicy"
"__builtin__.string" #.. "core.RestartPolicy"
"__builtin__.string" #.. "core.ScopeSelectorOperator"
"__builtin__.string" #.. "core.SeccompProfileType"
"__builtin__.string" #.. "core.SecretType"
"__builtin__.string" #.. "core.ServiceAffinity"
"__builtin__.string" #.. "core.ServiceExternalTrafficPolicy"
"__builtin__.string" #.. "core.ServiceInternalTrafficPolicy"
"__builtin__.string" #.. "core.ServiceType"
"__builtin__.string" #.. "core.StorageMedium"
"__builtin__.string" #.. "core.TaintEffect"
"__builtin__.string" #.. "core.TerminationMessagePolicy"
"__builtin__.string" #.. "core.TolerationOperator"
"__builtin__.string" #.. "core.URIScheme"
"__builtin__.string" #.. "core.UniqueVolumeName"
"__builtin__.string" #.. "core.UnsatisfiableConstraintAction"
"__builtin__.string" #.. "discovery.AddressType"
"__builtin__.string" #.. "flowcontrol.ConditionStatus"
"__builtin__.string" #.. "flowcontrol.FlowDistinguisherMethodType"
"__builtin__.string" #.. "flowcontrol.FlowSchemaConditionType"
"__builtin__.string" #.. "flowcontrol.LimitResponseType"
"__builtin__.string" #.. "flowcontrol.PriorityLevelConfigurationConditionType"
"__builtin__.string" #.. "flowcontrol.PriorityLevelEnablement"
"__builtin__.string" #.. "flowcontrol.SubjectKind"
"__builtin__.string" #.. "networking.NetworkPolicyConditionReason"
"__builtin__.string" #.. "networking.NetworkPolicyConditionType"
"__builtin__.string" #.. "networking.PathType"
"__builtin__.string" #.. "networking.PolicyType"
"__builtin__.string" #.. "policy.FSGroupStrategyType"
"__builtin__.string" #.. "policy.FSType"
"__builtin__.string" #.. "policy.RunAsGroupStrategy"
"__builtin__.string" #.. "policy.RunAsUserStrategy"
"__builtin__.string" #.. "policy.SELinuxStrategy"
"__builtin__.string" #.. "policy.SupplementalGroupsStrategyType"
"__builtin__.string" #.. "policy.UnhealthyPodEvictionPolicyType"
"__builtin__.string" #.. "resource.AllocationMode"
"__builtin__.string" #.. "storage.FSGroupPolicy"
"__builtin__.string" #.. "storage.VolumeBindingMode"
"__builtin__.string" #.. "storage.VolumeLifecycleMode"
"core.fontcolorbluemapfontResourceNameresourceQuantity" #.. "core.ResourceList"
"core.internalversionList" #.. "core.List"
"pods.fontcolorbluefuncfontcoreContainerfieldPathbool" #.. "pods.ContainerVisitorWithPath"
"qos.fontcolorbluemapfontv1ResourceNamev1PodQOSClass" #.. "qos.QOSList"
"rbac.[]PolicyRule" #.. "rbac.SortableRuleSlice"
"util.flowcontrolFlowSchema" #.. "util.FlowSchemaSequence"
"v1.v1PolicyRule" #.. "v1.SortableRuleSlice"
"validation.validationValidateNameFunc" #.. "validation.ValidateNameFunc"
@enduml
